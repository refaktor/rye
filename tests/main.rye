; Testing and Documenting frameworks that do test and generate html reference docs
; Run test cases: ../rye main.rye test
; Generate documentation: ../rye main.rye doc > builtins.html

rye .Args\raw? |load :args
root-ctx:: current

t: ?term

test-framework: context {

	var 'cnt 0
	var 'failed 0
	
	section: fn { name descr code } { term/magenta term/bold print name term/reset print " " ++ descr , do code print "" }
	
	group: fn { name descr args code example } { print "" , inc! 'cnt t/yellow prns " " ++ name t/reset , do  code }
	
	error: fn { test } {
		; try { do\in root-ctx test }
		try test :got |type? |= 'error |either { t/br-green prns join { "✓" } } { inc! 'failed , t/red prns " ✗ Failed:" t/reset   prns join { "expected error but got: " t/str\br-black inspect got t/str\reset } }
	}

	equal: fn { test res } {
		ctx: extends root-ctx { }
		do\inside ctx test :got = res
		|either { t/green prns "✓" t/reset } { inc! 'failed , t/red prns " ✗ Failed:" t/reset prns join { "expected " t/str\br-black inspect res t/str\reset ", got " t/str\br-black inspect got t/str\reset } }
	}
	
	stdout: fn { test res } {
		cc: extends root-ctx { }
		capture-stdout { do\inside cc test } :got = res
		|either { term/green prns "✓" term/reset } { inc! 'failed , term/red prns " ✗ Failed:" term/reset  prns join { "expected " t/str\br-black inspect res t/str\reset ", got " t/str\br-black inspect got t/str\reset } }
	}

	comment: fn { str } { }

	example: fn { str } { }

	end: fn { } { ;prns "Tests:" term/bold prn cnt term/reset\bold , print "FAILED: " + failed , if failed > 0 { exit 1 } }
		prns "\nGroups:" term/bold prn cnt term/reset\bold
		either is-zero failed
		{ term/bold term/green print "\nALL PASSED" term/reset }
		{ term/red print "\nFailed tests: " ++ failed  term/reset }
		;if failed > 0 { exit 1 }
		; exit 0
		failed
	}
}

escape-html: fn { x } { x |replace "&" "&amp;" |replace "<" "&lt;" |replace ">" "&gt;" }

docs-framework: context {

	section: fn { name descr code } { print join [ "<h2>" name "</h2><p>" descr "</p><div class='section'>" ] , do code , print "</div>" }
	
	group: fn { name descr args code example }   {
		print join [ "<h3>" name "</h3><p>" descr "</p>" ] ,
		do args ,
		if code .length? > 0 {
			print "<div class='group'>" , do code , print "</div>"
		}
		if all { example .length? > 0 example -> 0 |length? > 0 } {
			prn "<div class='group'>" , 
			prn "<pre class='prettyprint lang-rye'><code language='lang-rye'>"
			print escape-html first example
			print "</code></pre>"
			print "</div>"
		}
	}

	equal: fn { test res } {
		cc: extends root-ctx { }
		do\inside cc test :got = res
		|if { print join [ "<pre class='prettyprint lang-rye'><code language='lang-rye'>" escape-html mold\nowrap test newline "; returns "  replace escape-html mold got newline newline ++ "; "  "</code></pre>" ] }
	}

	error: fn { test } {
		; try { do\inside root-ctx test }
		test |try :got |type? |= 'error
		|if { print join [ "<pre class='prettyprint lang-rye'><code language='lang-rye'>" escape-html mold\nowrap test newline "; correctly causes error:\n; " message? got " </code></pre>" ] }
	}

	stdout: fn { test res } {
		cc: extends root-ctx { }
		capture-stdout { do\inside cc test } :got = res
		|if { print join [ "<pre class='prettyprint lang-rye'><code language='lang-rye'>" escape-html mold\nowrap test newline "; prints " replace escape-html mold\nowrap got newline newline ++ "; " "</code></pre>" ] }
	}

	comment: fn { str } {
		print join [ "<p class='comment'>" to-string str "</p>" ]
	}

	example: fn { test } {
		print join [ "<pre class='prettyprint lang-rye'><code language='lang-rye'>" escape-html mold\nowrap test newline "</code></pre>" ]
	}

	arg: fn { str } {
		print join [ "<p class='arg'>" join prep-arg str "</p>" ]
	}
	
	returns: fn { str } {
		print join [ "<p class='returns'><b>returns</b> " str "</p>" ]
	}
	
	end: fn { } { }

	prep-arg: fn { s } { .split ":" :x |length? > 1 |either { [ "<b>" first x "</b>" second x ] } { [ first x ] } }

}

generate-menu: fn { menu } {
	.fold\do 'acc "" { ::x acc .concat " &middot; <a class='menu-item' id='maintab-{{}}' href='{{}}.html'>{{}}</a>" .replace "{{}}" x }
}

generate-doc-file: fn { filename menu } {
	join {
		%tpl/header.html .Read .replace "{{title}}" capitalize join [ "Rye function reference: " filename " ( updated: " to-string date? now " )" ]
		|replace "{{menu}}" generate-menu menu
		capture-stdout { do\inside docs-framework load to-file filename ++ ".info.rye" }
		Read %tpl/footer.html
	 } |Write* to-file filename ++ ".html"
}

menu: { "base" "table" "formats" "io" "crypto" "dialects" "protocols" }

print-help: does {
	print `# Rye's simple testing tool
	
 use test or doc command

Examples: 
 rye . test           # runs all tests
 rye . doc            # generates the docs out of tests
 rye . test ls        # lists the test sections available
 rye . test basics    # runs a specific test section
`
}

first args |^fix { print-help } |switch {
test {
	var 'sections { }
	either args .length? > 1 {
		either probe ( ( second args ) = 'ls ) {
			print "Test sections available:"
			menu .for { .concat* " * " |print }
		} {
			sections:: [ second args ]
		}
	} {
		sections:: menu
	}
	if sections .length? > 0 {  ; todo add is-empty builtin
		var 'errors 0
		for sections {
			.to-string .pass { term/bold , prns "\n#" , .to-upper .prns , print "#\n" }
			| ++ ".info.rye" |to-file |load |^check { "Group does not exist!!!!" } |do\inside* test-framework |+ errors |fix { errors } ::errors }
		print ""
	
		; if ( length? sections ) > 1 {
			term/yellow
			term/bold
			print "TOTAL FAILED TESTS: " ++ errors
			print ""
			term/reset
		; }
		print ""
		either errors > 0 { exit 1 } { exit 0 }
	}
}
doc  {
	for menu { .generate-doc-file menu }
	print "docs generated" 
}
_ { print-help }
} |probe

;   maybe we need this at some point 
;	true: fn { test } {
;		do-in root-ctx test
;		|either { print "  - OK" } { print "  - Error: not True" }
;	}
