section "Boolean " "Functions that work with true and false values." {
	group "true" 
	"Returns a boolean true value."
	{
		arg `none`
		returns `boolean true value`
	}

	{
		equal { true } true
		equal { true |type? } 'boolean
	}

	{
``	}

	group "false" 
	"Returns a boolean false value."
	{
		arg `none`
		returns `boolean false value`
	}

	{
		equal { false } false
		equal { false |type? } 'boolean
	}

	{
``	}

	group "not" 
	"Performs logical negation on boolean values only."
	{
		arg `value: Boolean value to be negated`
		returns `boolean false if the input is true, true if the input is false`
	}

	{
		equal { not true } false
		equal { not false } true
		error { not 0 }
		error { not 5 }
	}

	{
``	}

	group "and" 
	"Performs a logical AND operation between two boolean values, or a bitwise AND operation between two integer values."
	{
		arg `value1: First value (boolean or integer)`
		arg `value2: Second value (boolean or integer)`
		returns `boolean result of logical AND operation if both inputs are booleans, otherwise integer result of bitwise AND`
	}

	{
		equal { true .and true } true
		equal { false .and true } false
		equal { true .and false } false
		equal { false .and false } false
		equal { 3 .and 5 } 1  ; bitwise 011 AND 101 = 001
		error { true .and 5 }
		error { 5 .and true }
		error { "string" .and true }
	}

	{
``	}

	group "or" 
	"Performs a logical OR operation between two boolean values, or a bitwise OR operation between two integer values."
	{
		arg `value1: First value (boolean or integer)`
		arg `value2: Second value (boolean or integer)`
		returns `boolean result of logical OR operation if both inputs are booleans, otherwise integer result of bitwise OR`
	}

	{
		equal { true .or true } true
		equal { false .or true } true
		equal { true .or false } true
		equal { false .or false } false
		equal { 3 .or 5 } 7  ; bitwise 011 OR 101 = 111
		error { true .or 5 }
		error { 5 .or true }
		error { "string" .or true }
	}

	{
``	}

	group "xor" 
	"Performs a logical XOR (exclusive OR) operation between two boolean values, or a bitwise XOR operation between two integer values."
	{
		arg `value1: First value (boolean or integer)`
		arg `value2: Second value (boolean or integer)`
		returns `boolean result of logical XOR operation if both inputs are booleans, otherwise integer result of bitwise XOR`
	}

	{
		equal { true .xor true } false
		equal { false .xor true } true
		equal { true .xor false } true
		equal { false .xor false } false
		equal { 3 .xor 5 } 6  ; bitwise 011 XOR 101 = 110
		error { true .xor 5 }
		error { 5 .xor true }
		error { "string" .xor true }
	}

	{
``	}

	group "all" 
	"Evaluates all expressions in a block and returns the last value if all are truthy, or the first falsy value encountered."
	{
		arg `block: Block of expressions to evaluate`
		returns `the last value if all expressions are truthy, otherwise the first falsy value encountered`
	}

	{
		equal { all { 1 2 3 } } 3
		equal { all { 1 0 3 } } 3
		equal { all { 1 false 3 } } false
		equal { all { true true true } } true
		; equal { all { } } ? ; empty block behavior
		error { all "not-a-block" }
	}

	{
``	}

	group "any" 
	"Evaluates expressions in a block until a truthy value is found and returns it, or returns the last value if none are truthy."
	{
		arg `block: Block of expressions to evaluate`
		returns `the first truthy value encountered, or the last value if none are truthy`
	}

	{
		equal { any { 1 2 3 } } 1
		equal { any { 0 1 3 } } 0
		equal { any { false false 3 } } 3
		equal { any { false false false } } false
		; equal { any { } } ? ; empty block behavior
		error { any "not-a-block" }
	}

	{
``	}

	group "any\\with" 
	"Applies each expression in the block to the provided value until a truthy result is found and returns it."
	{
		arg `value: Value to be used as input to each expression in the block`
		arg `block: Block of expressions to evaluate with the provided value injected`
		returns `the first truthy result of applying an expression to the value, or the last result if none are truthy`
	}

	{
		equal { any\with 10 { + 10 , * 10 } } 20
		equal { any\with 0 { + 10 , * 10 } } 10
		equal { any\with 5 { - 10 , + 10 } } -5
		equal { any\with false { .not , .to-string } } true
		; equal { any\with true { .not , .to-string } } "true"
		error { any\with 5 "not-a-block" }
	}

	{
``	}

}

section "Numbers " "Working with numbers, integers and decimals." {
	group "addnums" 
	"Optimized version of + that adds two numbers, working with both integers and decimals."
	{
		arg `value1: Integer, decimal, or time value`
		arg `value2: Integer or decimal value (or integer for time addition)`
		returns `sum of the two numbers or time shifted by the integer offset`
	}

	{
		equal { addnums 2 3 } 5
		equal { addnums 2.5 3.5 } 6.0
		equal { addnums 2 3.5 } 5.5
	}

	{
``	}

	group "inc" 
	"Increments an integer value by 1."
	{
		arg `value: Integer to increment`
		returns `integer value incremented by 1`
	}

	{
		equal { inc 123 } 124
		equal { inc 0 } 1
		equal { inc -5 } -4
		error { inc "123" }
	}

	{
``	}

	group "dec" 
	"Decrements an integer value by 1."
	{
		arg `value: Integer to decrement`
		returns `integer value decremented by 1`
	}

	{
		equal { dec 124 } 123
		equal { dec 1 } 0
		equal { dec -4 } -5
		error { dec "123" }
	}

	{
``	}

	group "negate" 
	"Negates a number by multiplying it by -1, works with integers, decimals, and complex numbers."
	{
		arg `value: Number (integer, decimal, or complex) to negate`
		returns `negated number of the same type`
	}

	{
		equal { negate 123 } -123
		equal { negate -123 } 123
		equal { negate 0 } 0
		equal { negate 5.5 } -5.5
		equal { negate -2.3 } 2.3
		error { negate "123" }
	}

	{
``	}

	group "invert" 
	"Calculates the reciprocal (1/x) of a number, works with integers, decimals, and complex numbers."
	{
		arg `value: Number (integer, decimal, or complex) to invert (must not be zero)`
		returns `reciprocal (1/value) as decimal or complex number`
	}

	{
		equal { invert 2 } 0.5
		equal { invert 4 } 0.25
		equal { invert 0.5 } 2.0
		equal { invert -2 } -0.5
		equal { invert 1 } 1.0
		error { invert 0 }
		error { invert "123" }
	}

	{
``	}

	group "is-positive" 
	"Checks if a number is positive (greater than zero)."
	{
		arg `value: Integer or decimal to check`
		returns `boolean true if the value is positive, false otherwise`
	}

	{
		equal { is-positive 123 } true
		equal { is-positive -123 } false
		equal { is-positive 0 } false
		equal { is-positive 5.5 } true
		error { is-positive "123" }
	}

	{
``	}

	group "sign" 
	"Returns the sign of a number as -1, 0, or 1."
	{
		arg `value: Integer or decimal to check`
		returns `integer sign of the value (-1 for negative, 0 for zero, 1 for positive)`
	}

	{
		equal { sign 123 } 1
		equal { sign -123 } -1
		equal { sign 0 } 0
		equal { sign 5.5 } 1
		equal { sign -0.5 } -1
		error { sign "123" }
	}

	{
``	}

	group "is-zero" 
	"Checks if a number is exactly zero."
	{
		arg `value: Integer or decimal to check`
		returns `boolean true if the value is zero, false otherwise`
	}

	{
		equal { is-zero 0 } true
		equal { is-zero 123 } false
		equal { is-zero 0.0 } true
		error { is-zero "123" }
	}

	{
``	}

	group "is-multiple-of" 
	"Checks if the first integer is evenly divisible by the second integer."
	{
		arg `value: Integer to check`
		arg `divisor: Integer divisor to check against`
		returns `boolean true if value is divisible by divisor with no remainder, false otherwise`
	}

	{
		equal { 10 .is-multiple-of 2 } true
		equal { 10 .is-multiple-of 3 } false
		equal { 15 .is-multiple-of 5 } true
		equal { 0 .is-multiple-of 5 } true
	}

	{
``	}

	group "is-odd" 
	"Checks if an integer is odd (not divisible by 2)."
	{
		arg `value: Integer to check`
		returns `boolean true if the value is odd, false if even`
	}

	{
		equal { 3 .is-odd } true
		equal { 2 .is-odd } false
		equal { 0 .is-odd } false
		equal { -5 .is-odd } true
	}

	{
``	}

	group "is-even" 
	"Checks if an integer is even (divisible by 2)."
	{
		arg `value: Integer to check`
		returns `boolean true if the value is even, false if odd`
	}

	{
		equal { 3 .is-even } false
		equal { 2 .is-even } true
		equal { 0 .is-even } true
		equal { -4 .is-even } true
	}

	{
``	}

	group "mod" 
	"Calculates the modulo (remainder) when dividing the first integer by the second."
	{
		arg `value: Integer dividend`
		arg `divisor: Integer divisor`
		returns `integer remainder after division`
	}

	{
		equal { 4 .mod 2 } 0
		equal { 5 .mod 2 } 1
		equal { 5 .mod 3 } 2
		equal { -5 .mod 3 } -2
	}

	{
``	}

	group "_%" 
	"Alias for mod - calculates the modulo (remainder) when dividing the first integer by the second."
	{
		arg `value: Integer dividend`
		arg `divisor: Integer divisor`
		returns `integer remainder after division`
	}

	{
		equal { 4 % 2 } 0
		equal { 5 % 2 } 1
		equal { 5 % 3 } 2
	}

	{
``	}

	group "random\\integer" 
	"Generates a cryptographically secure random integer between 0 (inclusive) and the specified maximum (exclusive)."
	{
		arg `max: Upper bound (exclusive) for the random number`
		returns `random integer in the range [0, max)`
	}

	{
		equal { random\integer 2 |type? } 'integer
		equal { random\integer 1 |< 2 } true
		equal { random\integer 100 | >= 0 } true
	}

	{
``	}

	group "random\\decimal" 
	"Generates a cryptographically secure random decimal between 0.0 (inclusive) and the specified maximum (exclusive)."
	{
		arg `max: Upper bound (exclusive) for the random number`
		returns `random decimal in the range [0.0, max)`
	}

	{
		equal { random\decimal 2.0 |type? } 'decimal
		equal { random\decimal 1.0 |< 1.0 } true
		equal { random\decimal 100.0 | >= 0.0 } true
	}

	{
``	}

	group "inc!" 
	"Increments an integer value stored in a variable (word) by 1 and updates the variable in-place."
	{
		arg `word: Word referring to an integer value to increment`
		returns `the new incremented integer value`
	}

	{
		equal { a:: 123 inc! 'a a } 124
		equal { counter:: 0 inc! 'counter counter } 1
		error { inc! 123 }
	}

	{
``	}

	group "dec!" 
	"Decrements an integer value stored in a variable (word) by 1 and updates the variable in-place."
	{
		arg `word: Word referring to an integer value to decrement`
		returns `the new decremented integer value`
	}

	{
		equal { a:: 123 dec! 'a a } 122
		equal { counter:: 1 dec! 'counter counter } 0
		error { dec! 123 }
	}

	{
``	}

	group "_." 
	"Discards the input value and returns a void value, useful only for Eyr (stack based dialect)."
	{
		arg `value: Any value to discard`
		returns `void value (used to discard values)`
	}

	{
		equal { 4 . .type? } 'void
		equal { "hello" . .type? } 'void
	}

	{
``	}

	group "_+" 
	"Adds two numerical values. Accepts Integer, Decimal, Complex, Time and Vector."
	{
		arg `value1: First value (integer, decimal, complex, time, vector)`
		arg `value2: Second value to add (integer, decimal, complex, duration, vector)`
		returns `result of adding values, type depends on input types`
	}

	{
		equal { 1 + 1 } 2
		equal { 3 + 4 } 7
		equal { 5.6 + 7.8 } 13.400000
		equal { vector [ 1 2 3 ] |+ vector [ 4 5 6 ] |to-block } { 5.0 7.0 9.0 }
	}

	{
``	}

	group "_-" 
	"Subtracts the second number from the first, working with integers, decimals, complex numbers, and vectors."
	{
		arg `value1: First number (integer, decimal, or vector)`
		arg `value2: Second number to subtract from the first`
		returns `result of subtracting value2 from value1`
	}

	{
		equal { 2 - 1 } 1
		equal { 5 - 6 } -1
		equal { 5.5 - 2.2 } 3.3
		equal { 5 - 2.5 } 2.5
		equal { vector [ 5 7 9 ] |- vector [ 4 5 6 ] |to-block } { 1.0 2.0 3.0 }
	}

	{
``	}

	group "_*" 
	"Multiplies two numbers, working with integers, decimals, complex numbers, and vectors (scalar multiplication)."
	{
		arg `value1: First number (integer, decimal, or vector)`
		arg `value2: Second number to multiply by (scalar for vectors)`
		returns `product of the two numbers, or scaled vector`
	}

	{
		equal { 4 * 2 } 8
		equal { 2.5 * -2 } -5.0
		equal { 0 * 5 } 0
		equal { 1.5 * 2.5 } 3.75
		equal { vector [ 1 2 3 ] |* 2.0 |to-block } { 2.0 4.0 6.0 }
		equal { vector [ 10 20 ] |* 0.5 |to-block } { 5.0 10.0 }
	}

	{
``	}

	group "_/" 
	"Divides the first number by the second and returns a result, with error checking for division by zero."
	{
		arg `value1: Dividend (integer or decimal)`
		arg `value2: Divisor (integer or decimal, must not be zero)`
		returns `decimal result of dividing value1 by value2`
	}

	{
		equal { 4 / 2 } 2.000
		equal { 102.0 / 2.0 } 51.000
		equal { 5 / 2 } 2.5
		error { 5 / 0 }
	}

	{
``	}

	group "_//" 
	"Performs integer division, dividing the first number by the second and truncating to an integer result."
	{
		arg `value1: Dividend (integer or decimal)`
		arg `value2: Divisor (integer or decimal, must not be zero)`
		returns `integer result of dividing value1 by value2 (truncated)`
	}

	{
		equal { 5 // 2 } 2
		equal { 102 // 5 } 20
		equal { 7.99 // 2 } 3
		equal { -5 // 2 } -2
		error { 5 // 0 }
	}

	{
``	}

	group "_=" 
	"Compares two values for equality, returning 1 if equal or 0 if not equal."
	{
		arg `value1: First value to compare`
		arg `value2: Second value to compare`
		returns `boolean true if values are equal, false otherwise`
	}

	{
		equal { 5 = 5 } true
		equal { 5 = 4 } false
		equal { "abc" = "abc" } true
		equal { { 1 2 } = { 1 2 } } true
		equal { { 1 2 } = { 2 1 } } false
	}

	{
``	}

	group "_>" 
	"Compares if the first value is greater than the second value."
	{
		arg `value1: First value to compare`
		arg `value2: Second value to compare`
		returns `boolean true if value1 is greater than value2, false otherwise`
	}

	{
		equal { 6 > 5 } true
		equal { 5 > 5 } false
		equal { 4 > 5 } false
		equal { 5.5 > 5 } true
		equal { "b" > "a" } true
	}

	{
``	}

	group "_>=" 
	"Compares if the first value is greater than or equal to the second value."
	{
		arg `value1: First value to compare`
		arg `value2: Second value to compare`
		returns `boolean true if value1 is greater than or equal to value2, false otherwise`
	}

	{
		equal { 5 >= 6 } false
		equal { 5 >= 5 } true
		equal { 6.0 >= 5 } true
		equal { 4 >= 5 } false
		equal { "b" >= "a" } true
		equal { "a" >= "a" } true
	}

	{
``	}

	group "_<" 
	"Compares if the first value is less than the second value."
	{
		arg `value1: First value to compare`
		arg `value2: Second value to compare`
		returns `boolean true if value1 is less than value2, false otherwise`
	}

	{
		equal { 5 < 6 } true
		equal { 5 < 5 } false
		equal { 6 < 5 } false
		equal { 4.5 < 5 } true
		equal { "a" < "b" } true
	}

	{
``	}

	group "_<=" 
	"Compares if the first value is less than or equal to the second value."
	{
		arg `value1: First value to compare`
		arg `value2: Second value to compare`
		returns `boolean true if value1 is less than or equal to value2, false otherwise`
	}

	{
		equal { 5 <= 6 } true
		equal { 5 <= 5 } true
		equal { 6 <= 5 } false
		equal { 4.5 <= 5 } true
		equal { "a" <= "b" } true
		equal { "a" <= "a" } true
	}

	{
``	}

	group "clamp" 
	"Clamps a number between a minimum and maximum value, ensuring the result stays within the specified bounds."
	{
		arg `value: Number (integer or decimal) to clamp`
		arg `min: Minimum value (integer or decimal)`
		arg `max: Maximum value (integer or decimal)`
		returns `clamped number, ensuring value is between min and max (inclusive)`
	}

	{
		equal { clamp 5 0 10 } 5
		equal { clamp -5 0 10 } 0
		equal { clamp 15 0 10 } 10
		equal { clamp 5.5 0.0 10.0 } 5.5
		equal { clamp -2.3 0 10 } 0.0
		equal { clamp 12.7 0 10 } 10.0
		error { clamp "5" 0 10 }
	}

	{
``	}

}

section "Strings " "" {
	group "newline" 
	"Returns a string containing a single newline character."
	{
		arg `none`
		returns `a string containing a single newline character`
	}

	{
		equal { newline } "\n"
	}

	{
``	}

	group "tab" 
	"Returns a string containing a single tab character."
	{
		arg `none`
		returns `a string containing a single tab character`
	}

	{
		equal { tab } "\t"
	}

	{
``	}

	group "ln" 
	"Appends a newline character to the end of a string."
	{
		arg `string: String to append a newline to`
		returns `a new string with a newline character appended`
	}

	{
		equal { "123" .ln } "123\n"
		equal { "hello" .ln } "hello\n"
	}

	{
``	}

	group "trim" 
	"Removes all leading and trailing whitespace characters from a string."
	{
		arg `string: String to trim`
		returns `a new string with leading and trailing whitespace removed`
	}

	{
		equal { trim " ASDF " } "ASDF"
		equal { trim "   ASDF   " } "ASDF"
		equal { trim "\t\nASDF\r\n" } "ASDF"
	}

	{
``	}

	group "trim\\" 
	"Removes all leading and trailing occurrences of the specified characters from a string."
	{
		arg `string: String to trim`
		arg `cutset: String containing the characters to trim`
		returns `a new string with specified characters removed from both ends`
	}

	{
		equal { trim\ "__ASDF__" "_" } "ASDF"
		equal { trim\ "##Hello##" "#" } "Hello"
	}

	{
``	}

	group "trim\\right" 
	"Removes all trailing occurrences of the specified characters from a string."
	{
		arg `string: String to trim`
		arg `cutset: String containing the characters to trim`
		returns `a new string with specified characters removed from the right end`
	}

	{
		equal { trim\right "__ASDF__" "_" } "__ASDF"
		equal { trim\right "  ASDF  " " " } "  ASDF"
		equal { trim\right "Hello!!!" "!" } "Hello"
	}

	{
``	}

	group "trim\\left" 
	"Removes all leading occurrences of the specified characters from a string."
	{
		arg `string: String to trim`
		arg `cutset: String containing the characters to trim`
		returns `a new string with specified characters removed from the left end`
	}

	{
		equal { trim\left "___ASDF__" "_" } "ASDF__"
		equal { trim\left "  ASDF  " " " } "ASDF  "
		equal { trim\left "###Hello" "#" } "Hello"
	}

	{
``	}

	group "replace" 
	"Replaces all occurrences of a substring with another string."
	{
		arg `string: Original string`
		arg `old: Substring to replace`
		arg `new: Replacement string`
		returns `a new string with all occurrences of old replaced by new`
	}

	{
		equal { replace "...xo..." "xo" "LoL" } "...LoL..."
		equal { replace "...xoxo..." "xo" "LoL" } "...LoLLoL..."
		equal { replace "hello world" "world" "everyone" } "hello everyone"
	}

	{
``	}

	group "substring" 
	"Extracts a portion of a string between the specified start and end positions."
	{
		arg `string: String to extract from`
		arg `start: Starting position (0-based, inclusive)`
		arg `end: Ending position (0-based, exclusive)`
		returns `a new string containing the specified substring`
	}

	{
		equal { substring "xoxo..." 0 4 } "xoxo"
		equal { substring "...xoxo..." 3 7 } "xoxo"
		equal { substring "hello world" 6 11 } "world"
	}

	{
``	}

	group "contains" 
	"Checks if a string, block or list contains a specific value, returning true if found or false if not found."
	{
		arg `collection: String, block or list to search in`
		arg `value: Value to search for`
		returns `true if the collection contains the value, false otherwise`
	}

	{
		equal { contains "...xoxo..." "xo"  } true
		equal { contains "...xoxo..." "lol" } false
		equal { contains { ".." "xoxo" ".." } "xoxo" } true
		equal { contains { ".." "xoxo" ".." } "lol"  } false
		equal { contains list { 1 2 3 } 2 } true
	}

	{
``	}

	group "has-suffix" 
	"Checks if a string ends with a specific suffix, returning true if it does or false if it doesn't."
	{
		arg `string: String to check`
		arg `suffix: Suffix to look for`
		returns `true if the string ends with the suffix, false otherwise`
	}

	{
		equal { has-suffix "xoxo..." "xoxo" } false
		equal { has-suffix "...xoxo" "xoxo" } true
		equal { has-suffix "hello.txt" ".txt" } true
	}

	{
``	}

	group "has-prefix" 
	"Checks if a string starts with a specific prefix, returning true if it does or false if it doesn't."
	{
		arg `string: String to check`
		arg `prefix: Prefix to look for`
		returns `true if the string starts with the prefix, false otherwise`
	}

	{
		equal { has-prefix "xoxo..." "xoxo" } true
		equal { has-prefix "...xoxo" "xoxo" } false
		equal { has-prefix "http://example.com" "http://" } true
	}

	{
``	}

	group "index?" 
	"Finds the 0-based index of the first occurrence of a value in a string or block."
	{
		arg `collection: String or block to search in`
		arg `value: Value to search for`
		returns `integer index (0-based) of the first occurrence of the value, or -1 if not found`
	}

	{
		equal { index? "...xo..." "xo" } 3
		equal { index? "xo..." "xo" } 0
		equal { index? { "xo" ".." } "xo" } 0
		equal { index? { ".." "xo" ".." } "xo" } 1
	}

	{
``	}

	group "position?" 
	"Finds the 1-based position of the first occurrence of a value in a string or block."
	{
		arg `collection: String or block to search in`
		arg `value: Value to search for`
		returns `integer position (1-based) of the first occurrence of the value, or error if not found`
	}

	{
		equal { position? "...xo..." "xo" } 4
		equal { position? "xo..." "xo" } 1
		equal { position? { "xo" ".." } "xo" } 1
		equal { position? { ".." "xo" ".." } "xo" } 2
	}

	{
``	}

	group "encode-to\\base64" 
	"Encodes a string or binary data as a base64 string."
	{
		arg `data: String or native bytes/pem-block to encode`
		returns `base64-encoded string`
	}

	{
		equal { encode-to\base64 "abcd" } "YWJjZA=="
		equal { encode-to\base64 "hello world" } "aGVsbG8gd29ybGQ="
	}

	{
``	}

	group "decode\\base64" 
	"Decodes a base64-encoded string back to its original form."
	{
		arg `string: Base64-encoded string to decode`
		returns `decoded string`
	}

	{
		equal { decode\base64 encode-to\base64 "abcd" } "abcd"
		equal { decode\base64 "aGVsbG8gd29ybGQ=" } "hello world"
	}

	{
``	}

	group "space" 
	"Appends a space character to the end of a string."
	{
		arg `string: String to append a space to`
		returns `a new string with a space character appended`
	}

	{
		equal { "abcd" .space } "abcd "
		equal { "" .space } " "
	}

	{
``	}

	group "capitalize" 
	"Converts the first character of a string to uppercase, leaving the rest unchanged."
	{
		arg `string: String to capitalize`
		returns `a new string with the first character converted to uppercase`
	}

	{
		equal { capitalize "abcde" } "Abcde"
		equal { capitalize "hello world" } "Hello World"
		equal { capitalize "HELLO" } "Hello"
	}

	{
``	}

	group "lower" 
	"Converts all characters in a string to lowercase."
	{
		arg `string: String to convert`
		returns `a new string with all characters converted to lowercase`
	}

	{
		equal { lower "ABCDE" } "abcde"
		equal { lower "Hello World" } "hello world"
		equal { lower "123ABC" } "123abc"
	}

	{
``	}

	group "upper" 
	"Converts all characters in a string to uppercase."
	{
		arg `string: String to convert`
		returns `a new string with all characters converted to uppercase`
	}

	{
		equal { upper "abcde" } "ABCDE"
		equal { upper "Hello World" } "HELLO WORLD"
		equal { upper "123abc" } "123ABC"
	}

	{
``	}

	group "concat3" 
	"Concatenates three strings together into a single string."
	{
		arg `string1: First string`
		arg `string2: Second string`
		arg `string3: Third string`
		returns `a new string containing all three strings concatenated together`
	}

	{
		equal { concat3 "aa" "BB" "cc" } "aaBBcc"
		equal { concat3 "hello" " " "world" } "hello world"
	}

	{
``	}

	group "join" 
	"Concatenates all strings, numbers or URIs in a block or list into a single string with no separator. If the first element is a URI, returns a URI."
	{
		arg `collection: Block or list of strings, numbers or URIs to join`
		returns `a single string with all values concatenated together, or a URI if first element is a URI`
	}

	{
		equal { join { "Mary" "Anne" } } "MaryAnne"
		equal { join { "Spot" "Fido" "Rex" } } "SpotFidoRex"
		equal { join { 1 2 3 } } "123"
		equal { join { https://example.com/ "path" } |type? } 'uri
	}

	{
``	}

	group "join\\with" 
	"Concatenates all strings or numbers in a block or list into a single string with a specified delimiter between values."
	{
		arg `collection: Block or list of strings or numbers to join`
		arg `delimiter: String to insert between each value`
		returns `a single string with all values concatenated with the delimiter between them`
	}

	{
		equal { join\with { "Mary" "Anne" } " " } "Mary Anne"
		equal { join\with { "Spot" "Fido" "Rex" } "/" } "Spot/Fido/Rex"
		equal { join\with { 1 2 3 } "-" } "1-2-3"
	}

	{
``	}

	group "split" 
	"Splits a string into a block of strings using a separator string."
	{
		arg `string: String to split`
		arg `separator: String that separates values`
		returns `a block of strings resulting from splitting the input string`
	}

	{
		equal { split "a,b,c" "," } { "a" "b" "c" }
		equal { split "hello world" " " } { "hello" "world" }
		equal { split "one::two::three" "::" } { "one" "two" "three" }
	}

	{
``	}

	group "split\\quoted" 
	"Splits a string into a block of strings using a separator, while respecting quoted sections that should remain intact."
	{
		arg `string: String to split`
		arg `separator: String that separates values`
		arg `quote: String that marks quoted sections that should not be split`
		returns `a block of strings resulting from splitting the input string, preserving quoted sections`
	}

	{
		equal { split\quoted "`a,b`,c,d" "," "`" } { "`a,b`" "c" "d" }
		equal { split\quoted "'hello, world',foo,bar" "," "'" } { "'hello, world'" "foo" "bar" }
	}

	{
``	}

	group "split\\many" 
	"Splits a string into a block of strings using any character in the separators string as a delimiter."
	{
		arg `string: String to split`
		arg `separators: String containing all characters that should be treated as separators`
		returns `a block of strings resulting from splitting the input string at any of the separator characters`
	}

	{
		equal { split\many "192.0.0.1" "." } { "192" "0" "0" "1" }
		equal { split\many "abcd..e.q|bar" ".|" } { "abcd" "e" "q" "bar" }
		equal { split\many "a;b,c:d" ";,:" } { "a" "b" "c" "d" }
	}

	{
``	}

	group "split\\every" 
	"Splits a string or block into chunks of the specified size, with any remaining elements in the last chunk."
	{
		arg `collection: String or block to split`
		arg `size: Number of elements in each chunk`
		returns `a block of strings or blocks, each containing at most 'size' elements`
	}

	{
		equal { split\every "abcdefg" 3 } { "abc" "def" "g" }
		equal { split\every "abcdefg" 2 } { "ab" "cd" "ef" "g" }
		equal { split\every "abcdef" 2 } { "ab" "cd" "ef" }
		equal { split\every { 1 2 3 4 5 } 2 } { { 1 2 } { 3 4 } { 5 } }
	}

	{
``	}

}

section "Date and Time " "" {
	group "unix-micro?" 
	"Converts a time object to Unix time in microseconds (microseconds since January 1, 1970 UTC)."
	{
		arg `time: Time object to convert`
		returns `integer representing Unix time in microseconds`
	}

	{
		equal { now |unix-micro? |type? } 'integer
	}

	{
``	}

	group "unix-milli?" 
	"Converts a time object to Unix time in milliseconds (milliseconds since January 1, 1970 UTC)."
	{
		arg `time: Time object to convert`
		returns `integer representing Unix time in milliseconds`
	}

	{
		equal { now |unix-milli? |type? } 'integer
	}

	{
``	}

	group "weekday?" 
	"Extracts the day of the week from a time object as an integer (0=Sunday through 6=Saturday)."
	{
		arg `time: Time object to extract weekday from`
		returns `integer representing day of week (0=Sunday, 1=Monday, ..., 6=Saturday)`
	}

	{
		equal { date "2023-01-01" |weekday? } 0  ; Sunday is 0
	}

	{
``	}

	group "date" 
	"Creates a time object from a date string in YYYY-MM-DD format."
	{
		arg `datestr: String in "YYYY-MM-DD" format`
		returns `time object representing the specified date`
	}

	{
		equal { date "2023-01-15" |type? } 'time
		equal { date "2023-01-15" |day? } 15
	}

	{
``	}

	group "datetime" 
	"Creates a time object from a datetime string in YYYY-MM-DDThh:mm:ss format."
	{
		arg `datetimestr: String in "YYYY-MM-DDThh:mm:ss" format`
		returns `time object representing the specified date and time`
	}

	{
		equal { datetime "2023-01-15T14:30:45" |type? } 'time
		equal { datetime "2023-01-15T14:30:45" |hour? } 14
	}

	{
``	}

	group "now" 
	"Creates a time object representing the current local time."
	{
		arg `none`
		returns `time object representing the current time`
	}

	{
		equal { now |type? } 'time
	}

	{
``	}

	group "yearday?" 
	"Extracts the day of year from a time object as an integer (1-366)."
	{
		arg `time: Time object to extract day of year from`
		returns `integer representing day of year (1-366)`
	}

	{
		equal { date "2023-01-15" |yearday? } 15  ; January 15 is the 15th day of the year
	}

	{
``	}

	group "year?" 
	"Extracts the year from a time object as an integer."
	{
		arg `time: Time object to extract year from`
		returns `integer representing the year`
	}

	{
		equal { date "2023-01-15" |year? } 2023
	}

	{
``	}

	group "month?" 
	"Extracts the month from a time object as an integer (1-12)."
	{
		arg `time: Time object to extract month from`
		returns `integer representing the month (1-12)`
	}

	{
		equal { date "2023-01-15" |month? } 1
	}

	{
``	}

	group "days-in-month?" 
	"Calculates the number of days in the month of the given time object."
	{
		arg `time: Time object to calculate days in month for`
		returns `integer representing the number of days in the month`
	}

	{
		equal { date "2023-01-15" |days-in-month? } 31
		equal { date "2023-02-15" |days-in-month? } 28
	}

	{
``	}

	group "time?" 
	"Extracts the time part from a time object as a formatted string (hh:mm:ss)."
	{
		arg `time: Time object to extract time from`
		returns `string representing the time in "hh:mm:ss" format`
	}

	{
		equal { datetime "2023-01-15T14:30:45" |time? } "14:30:45"
	}

	{
``	}

	group "date?" 
	"Extracts the date part from a time object as a formatted string (YYYY-MM-DD)."
	{
		arg `time: Time object to extract date from`
		returns `string representing the date in "YYYY-MM-DD" format`
	}

	{
		equal { datetime "2023-01-15T14:30:45" |date? } "2023-01-15"
	}

	{
``	}

	group "format-imap-date" 
	"Formats a time object as an IMAP search date string (DD-Mon-YYYY)."
	{
		arg `time: Time object to format`
		returns `string representing the date in IMAP search format (DD-Mon-YYYY)`
	}

	{
		equal { date "2023-01-15" |format-imap-date } "15-Jan-2023"
	}

	{
``	}

	group "format-date" 
	"Formats a time object using a Go time format layout string. Reference time: Mon Jan 2 15:04:05 MST 2006"
	{
		arg `time: Time object to format`
		arg `layout: String - Go time format layout (reference time: Mon Jan 2 15:04:05 MST 2006)`
		returns `string representing the formatted date/time`
	}

	{
		equal { date "2023-01-15" |format-date "2006-01-02" } "2023-01-15"
		equal { date "2023-01-15" |format-date "02/01/2006" } "15/01/2023"
		equal { datetime "2023-01-15T14:30:45" |format-date "Mon Jan 2 15:04:05 2006" } "Sun Jan 15 14:30:45 2023"
	}

	{
``	}

	group "day?" 
	"Extracts the day of month from a time object as an integer (1-31)."
	{
		arg `time: Time object to extract day from`
		returns `integer representing the day of month (1-31)`
	}

	{
		equal { date "2023-01-15" |day? } 15
	}

	{
``	}

	group "hour?" 
	"Extracts the hour from a time object as an integer (0-23)."
	{
		arg `time: Time object to extract hour from`
		returns `integer representing the hour (0-23)`
	}

	{
		equal { datetime "2023-01-15T14:30:45" |hour? } 14
	}

	{
``	}

	group "minute?" 
	"Extracts the minute from a time object as an integer (0-59)."
	{
		arg `time: Time object to extract minute from`
		returns `integer representing the minute (0-59)`
	}

	{
		equal { datetime "2023-01-15T14:30:45" |minute? } 30
	}

	{
``	}

	group "second?" 
	"Extracts the second from a time object as an integer (0-59)."
	{
		arg `time: Time object to extract second from`
		returns `integer representing the second (0-59)`
	}

	{
		equal { datetime "2023-01-15T14:30:45" |second? } 45
	}

	{
``	}

	group "sleep" 
	"Pauses execution for the specified number of milliseconds."
	{
		arg `milliseconds: Integer number of milliseconds to sleep`
		returns `the original milliseconds value`
	}

	{
		equal { time-it { sleep 10 } } 10
	}

	{
``	}

	group "thousands" 
	"Multiplies the input by 1000 (useful for unit conversion)."
	{
		arg `n: Integer`
		returns `integer multiplied by 1000`
	}

	{
		equal { 5 .thousands } 5000
	}

	{
``	}

	group "millions" 
	"Multiplies the input by 1000000 (useful for unit conversion)."
	{
		arg `n: Integer`
		returns `integer multiplied by 1000000`
	}

	{
		equal { 5 .millions } 5000000
	}

	{
``	}

	group "seconds" 
	"Converts seconds to milliseconds (multiplies by 1000)."
	{
		arg `n: Integer number of seconds`
		returns `integer representing the equivalent number of milliseconds`
	}

	{
		equal { 5 .seconds } 5000
	}

	{
``	}

	group "minutes" 
	"Converts minutes to milliseconds (multiplies by 60000)."
	{
		arg `n: Integer number of minutes`
		returns `integer representing the equivalent number of milliseconds`
	}

	{
		equal { 5 .minutes } 300000  ; 5000 * 60
	}

	{
``	}

	group "hours" 
	"Converts hours to milliseconds (multiplies by 3600000)."
	{
		arg `n: Integer number of hours`
		returns `integer representing the equivalent number of milliseconds`
	}

	{
		equal { 5 .hours } 18000000  ; 5000 * 60 * 60
	}

	{
``	}

	group "days" 
	"Converts days to milliseconds (multiplies by 86400000)."
	{
		arg `n: Integer number of days`
		returns `integer representing the equivalent number of milliseconds`
	}

	{
		equal { 5 .days } 432000000  ; 5000 * 60 * 60 * 24
	}

	{
``	}

	group "weeks" 
	"Converts weeks to milliseconds (multiplies by 604800000)."
	{
		arg `n: Integer number of weeks`
		returns `integer representing the equivalent number of milliseconds`
	}

	{
		equal { 5 .weeks } 3024000000  ; 5000 * 60 * 60 * 24 * 7
	}

	{
``	}

	group "time-it" 
	"Accepts a block, does it and times it's execution time."
	{
		arg `block: Block of code to execute and time`
		returns `integer representing execution time in milliseconds`
	}

	{
		equal { time-it { sleep 100 } } 100
	}

	{
``	}

}

section "Collections " "" {
	group "random" 
	"Selects a random value from a block of values."
	{
		arg `block: Block of values to select from`
		returns `a randomly selected value from the block`
	}

	{
		equal { random { 1 2 3 } |type? } 'integer
		equal { random { 1 2 3 } |contains* { 1 2 3 } } true
	}

	{
``	}

	group "unpack" 
	"Flattens a block of blocks or list of lists by one level, combining all inner collections into a single collection."
	{
		arg `collection: Block or list of blocks/lists to unpack`
		returns `a flattened block or list with all inner blocks/lists unpacked`
	}

	{
		equal { unpack { { 123 } { 234 } } } { 123 234 }
		equal { unpack { { { 123 } } { 234 } } } { { 123 } 234 }
		; equal { unpack list { list { 1 2 } list { 3 4 } } } list { 1 2 3 4 }
	}

	{
``	}

	group "sample" 
	"Randomly selects a specified number of elements from a collection without replacement."
	{
		arg `collection: Block, list or table to sample from`
		arg `count: Number of random elements to select`
		returns `a new collection with randomly selected elements`
	}

	{
		equal { sample { 1 2 3 4 } 2 |length? } 2
		equal { sample { 123 123 123 123 } 3 -> 0 } 123
		; equal { sample list { 1 2 3 4 5 } 3 |length? } 3
	}

	{
``	}

	group "max" 
	"Finds the maximum value in a block or list of comparable values."
	{
		arg `collection: Block or list of comparable values`
		returns `the maximum value in the collection`
	}

	{
		equal { max { 8 2 10 6 } } 10
		equal { max list { 8 2 10 6 } } 10
		equal { try { max { } } |type? } 'error
		equal { try { max list { } } |type? } 'error
	}

	{
``	}

	group "max\\by" 
	"Finds the value in a collection that produces the maximum result when transformed by a code block. Returns the original value, not the transformed result."
	{
		arg `collection: Block or list of values`
		arg `code: Block of code to transform each value for comparison`
		returns `the original value that produces the maximum result when transformed by the code block`
	}

	{
		equal { { 1 3 2 } |max\by { * -10 } } 1
		equal { { "a" "abc" "ab" } |max\by { .length? } } "abc"
		equal { { 5 -3 2 -8 } |max\by { .math/abs } } -8
		equal { list { 1 3 2 } |max\by { * -10 } } 1
	}

	{
``	}

	group "min" 
	"Finds the minimum value in a block or list of comparable values."
	{
		arg `collection: Block or list of comparable values`
		returns `the minimum value in the collection`
	}

	{
		equal { min { 8 2 10 6 } } 2
		equal { min list { 8 2 10 6 } } 2
		equal { try { min { } } |type? } 'error
		equal { try { min list { } } |type? } 'error
	}

	{
``	}

	group "min\\by" 
	"Finds the value in a collection that produces the minimum result when transformed by a code block. Returns the original value, not the transformed result."
	{
		arg `collection: Block or list of values`
		arg `code: Block of code to transform each value for comparison`
		returns `the original value that produces the minimum result when transformed by the code block`
	}

	{
		equal { { 3 1 2 } |min\by { * -10 } } 3
		equal { { "a" "abc" "ab" } |min\by { .length? } } "a"
		equal { { 5 -3 2 -8 } |min\by { .math/abs } } 2
		equal { list { 3 1 2 } |min\by { * -10 } } 3
	}

	{
``	}

	group "avg" 
	"Calculates the arithmetic mean (average) of numeric values in a collection."
	{
		arg `collection: Block, list or vector of numeric values`
		returns `the arithmetic mean (average) of the values as a decimal`
	}

	{
		equal { avg { 8 2 10 6 } } 6.5
		equal { avg list { 8 2 10 6 } } 6.5
		equal { avg { 1 2 3 } } 2.0
		equal { try { avg { } } |type? } 'error
		equal { try { avg list { } } |type? } 'error
	}

	{
``	}

	group "avg\\by" 
	"Calculates the average of the results of transforming each value in a collection by a code block. Returns the average of all transformed results."
	{
		arg `collection: Block or list of values`
		arg `code: Block of code to transform each value before averaging`
		returns `the average of all transformed results as a decimal`
	}

	{
		equal { { 1 2 3 } |avg\by { * 2 } } 4.0
		equal { { "a" "abc" "ab" } |avg\by { .length? } } 2.0
		equal { { 10 20 30 } |avg\by { / 10 } } 2.0
		equal { list { 2 4 6 } |avg\by { + 1 } } 5.0
	}

	{
``	}

	group "sum" 
	"Calculates the sum of all numeric values in a collection."
	{
		arg `collection: Block, list or vector of numeric values`
		returns `the sum of all values (integer if all values are integers, decimal otherwise)`
	}

	{
		equal { sum { 8 2 10 6 } } 26
		equal { sum { 8 2 10 6.5 } } 26.5
		equal { sum { } } 0
		equal { sum list { 8 2 10 6 } } 26
		equal { sum list { 8 2 10 6.5 } } 26.5
		equal { sum list { } } 0
	}

	{
``	}

	group "sum\\by" 
	"Sums the results of transforming each value in a collection by a code block. Returns the sum of all transformed results."
	{
		arg `collection: Block or list of values`
		arg `code: Block of code to transform each value before summing`
		returns `the sum of all transformed results (integer if all results are integers, decimal otherwise)`
	}

	{
		equal { { 1 2 3 } |sum\by { * 2 } } 12
		equal { { "a" "abc" "ab" } |sum\by { .length? } } 6
		equal { { 1.5 2.5 3.5 } |sum\by { * 2 } } 15.0
		equal { list { 1 2 3 4 } |sum\by { + 10 } } 50
	}

	{
``	}

	group "mul" 
	"Calculates the product of all numeric values in a collection."
	{
		arg `collection: Block, list or vector of numeric values`
		returns `the product of all values (integer if all values are integers, decimal otherwise)`
	}

	{
		equal { mul { 1 2 3 4 5 } } 120
		equal { mul { 1 2.0 3.3 4 5 } } 132.0
		equal { mul { 2 3 4 } } 24
	}

	{
``	}

	group "first" 
	"Retrieves the first item from a collection (block, list, string, or table)."
	{
		arg `collection: Block, list, string or table to get the first item from`
		returns `the first item in the collection`
	}

	{
		equal { first { 1 2 3 4 } } 1
		equal { first "abcde" } "a"
		equal { first list { 1 2 3 } } 1
		; equal { first table { 'a 'b } { 1 2 } { 3 4 } } table-row { 'a 1 'b 2 }
	}

	{
``	}

	group "rest" 
	"Creates a new collection with all items except the first one from the input collection."
	{
		arg `collection: Block, list or string to get all but the first item from`
		returns `a new collection containing all items except the first one`
	}

	{
		equal { rest { 1 2 3 4 } } { 2 3 4 }
		equal { rest "abcde" } "bcde"
		equal { rest list { 1 2 3 } } list { 2 3 }
		equal { rest { 1 } } { }
	}

	{
``	}

	group "rest\\from" 
	"Creates a new collection with all items starting from the specified position in the input collection."
	{
		arg `collection: Block, list or string to get items from`
		arg `n: Integer position to start from (0-based)`
		returns `a new collection containing all items starting from position n`
	}

	{
		equal { rest\from { 1 2 3 4 5 6 } 3 } { 4 5 6 }
		equal { rest\from "abcdefg" 1 } "bcdefg"
		equal { rest\from list { 1 2 3 4 } 2 } list { 3 4 }
		equal { rest\from { 1 2 3 } 0 } { 1 2 3 }
	}

	{
``	}

	group "tail" 
	"Creates a new collection with the last n items from the input collection."
	{
		arg `collection: Block, list, string or table to get the last items from`
		arg `n: Number of items to retrieve from the end`
		returns `a new collection containing the last n items`
	}

	{
		equal { tail { 1 2 3 4 5 6 7 } 3 } { 5 6 7 }
		equal { tail "abcdefg" 4 } "defg"
		equal { tail list { 1 2 3 4 } 1 } list { 4 }
		equal { tail { 1 2 } 5 } { 1 2 }
	}

	{
``	}

	group "second" 
	"Retrieves the second item from a collection (block, list, or string)."
	{
		arg `collection: Block, list or string to get the second item from`
		returns `the second item in the collection`
	}

	{
		equal { second { 123 234 345 } } 234
		equal { second "abc" } "b"
		equal { second list { 10 20 30 } } 20
	}

	{
``	}

	group "third" 
	"Retrieves the third item from a collection (block, list, or string)."
	{
		arg `collection: Block, list or string to get the third item from`
		returns `the third item in the collection`
	}

	{
		equal { third { 123 234 345 } } 345
		equal { third "abcde" } "c"
		equal { third list { 10 20 30 40 } } 30
	}

	{
``	}

	group "last" 
	"Retrieves the last item from a collection (block, list, or string)."
	{
		arg `collection: Block, list or string to get the last item from`
		returns `the last item in the collection`
	}

	{
		equal { last { 1 2 } } 2
		equal { last "abcd" } "d"
		equal { last list { 4 5 6 } } 6
		equal { try { last { } } |type? } 'error
	}

	{
``	}

	group "before-last" 
	"Creates a new collection with all items except the last one from the input collection."
	{
		arg `collection: Block, list or string to get all but the last item from`
		returns `a new collection containing all items except the last one`
	}

	{
		equal { before-last { 1 2 3 4 } } { 1 2 3 }
		equal { before-last "abcd" } "abc"
		equal { before-last list { 4 5 6 } } list { 4 5 }
		equal { before-last { 1 } } { }
		equal { try { all-before-last { } } |type? } 'error
	}

	{
``	}

	group "head" 
	"Creates a new collection with the first n items from the input collection, or all but the last |n| items if n is negative."
	{
		arg `collection: Block, list, string or table to get the first items from`
		arg `n: Number of items to retrieve (if positive) or number to exclude from the end (if negative)`
		returns `a new collection containing the first n items or all but the last |n| items`
	}

	{
		equal { head { 4 5 6 7 } 3 } { 4 5 6 }
		equal { head "abcdefg" 2 } "ab"
		equal { head "abcdefg" 4 } "abcd"
		equal { head list { 10 20 30 40 } 2 } list { 10 20 }
		equal { head { 4 5 6 7 } -2 } { 4 5 }
		equal { head "abcdefg" -1 } "abcdef"
		equal { head "abcdefg" -5 } "ab"
		equal { head list { 10 20 30 40 } -1 } list { 10 20 30 }
	}

	{
``	}

	group "nth" 
	"Retrieves the item at the specified position (1-based indexing) from a collection."
	{
		arg `collection: Block, list, string or table to get an item from`
		arg `n: Position of the item to retrieve (1-based)`
		returns `the item at position n in the collection`
	}

	{
		equal { nth { 1 2 3 4 5 } 4 } 4
		equal { nth { "a" "b" "c" "d" "e" } 2 } "b"
		; equal { nth "abcde" 3 } "c"
		equal { nth list { 10 20 30 40 } 2 } 20
		error { nth list { 10 20 30 40 } 0 }
		; equal { nth table { 'a 'b } { 1 2 } { 3 4 } 2 } table-row { 'a 3 'b 4 }
	}

	{
``	}

	group "values" 
	"Extracts all values from a dictionary and returns them as a list."
	{
		arg `dict: Dictionary object to extract values from`
		returns `list containing all values from the dictionary`
	}

	{
		equal { dict { "a" 1 "b" 2 "c" 3 } |values } list { 1 2 3 }
		equal { dict { "x" 10 "y" 20 } |values |length? } 2
	}

	{
``	}

	group "sort" 
	"Creates a new collection with items sorted in ascending order."
	{
		arg `collection: Block, list or string to sort`
		returns `a new collection with items sorted in ascending order`
	}

	{
		equal { sort { 6 12 1 } } { 1 6 12 }
		equal { sort x: { 6 12 1 } x } { 6 12 1 }
		equal { sort { "b" "c" "a" } } { "a" "b" "c" }
		equal { sort list { 5 3 1 4 } } list { 1 3 4 5 }
		equal { sort "cba" } "abc"
	}

	{
``	}

	group "sort!" 
	"Sorts a block or list in-place in ascending order and returns the modified collection."
	{
		arg `collection: Reference to a block or list to sort in-place`
		returns `the sorted collection (same reference, modified in-place)`
	}

	{
		error { x: { 6 12 1 } , sort! x }
		equal { x: ref { 6 12 1 } , sort! x , x } { 1 6 12 }
		equal { x: ref list { 5 3 1 4 } , sort! x , x } list { 1 3 4 5 }
	}

	{
``	}

	group "sort\\by" 
	"Creates a new collection with items sorted according to a custom comparison function."
	{
		arg `collection: Block or list to sort`
		arg `comparator: Function that takes two arguments and returns a truthy value if they are in the correct order`
		returns `a new collection with items sorted according to the comparator function`
	}

	{
		equal { sort\by { 6 12 1 } fn { a b } { a < b } } { 1 6 12 }
		equal { sort\by { 6 12 1 } fn { a b } { a > b } } { 12 6 1 }
		equal { sort\by { { x 6 } { x 12 } { x 1 } } fn { a b } { second a |< second b } } { { x 1 } { x 6 } { x 12 } }
		equal { sort\by list { 5 3 1 4 } fn { a b } { a > b } } list { 5 4 3 1 }
	}

	{
``	}

	group "sort\\by\\key" 
	"Efficiently sorts a collection by pre-computing a sort key for each element using a key function. Much faster than sort\\by for large datasets (Schwartzian Transform)."
	{
		arg `collection: Block or list to sort`
		arg `key-fn: Block of code that transforms each value to a sortable key (evaluated once per element)`
		returns `a new collection with items sorted according to the computed keys`
	}

	{
		equal { sort\by\key { 6 12 1 } { * -1 } } { 12 6 1 }
		equal { sort\by\key { 6 12 1 } { + 0 } } { 1 6 12 }
		equal { sort\by\key { { x 6 } { x 12 } { x 1 } } { .second } } { { x 1 } { x 6 } { x 12 } }
		equal { sort\by\key { "abc" "a" "ab" } { .length? } } { "a" "ab" "abc" }
		equal { sort\by\key list { 5 3 1 4 } { * -1 } } list { 5 4 3 1 }
	}

	{
``	}

	group "unique" 
	"Creates a new collection with duplicate values removed, keeping only the first occurrence of each value."
	{
		arg `collection: Block, list or string to remove duplicates from`
		returns `a new collection with duplicate values removed`
	}

	{
		equal { list { 3 2 3 5 3 2 } .unique |sort } list { 2 3 5 }
		equal { unique list { 1 1 2 2 3 } |sort } list { 1 2 3 }
		equal { unique list { 1 1 2 2 } |sort } list { 1 2 }
		equal { unique { 1 1 2 2 3 } |sort } { 1 2 3 }
		equal { unique { 1 1 2 2 } |sort } { 1 2 }
		equal { unique "aabbc" |length? } 3
		equal { unique "ab" |length? } 2
	}

	{
``	}

	group "reverse" 
	"Creates a new collection with items in reverse order from the input collection."
	{
		arg `collection: Block, list or string to reverse`
		returns `a new collection with items in reverse order`
	}

	{
		equal { reverse { 3 1 2 3 } } { 3 2 1 3 }
		equal { reverse "abcd" } "dcba"
		equal { reverse list { 1 2 3 4 } } list { 4 3 2 1 }
		equal { reverse { } } { }
	}

	{
``	}

	group "reverse!" 
	"Reverses a block or list in-place and returns the modified collection."
	{
		arg `collection: Reference to a block or list to reverse in-place`
		returns `the reversed collection (same reference, modified in-place)`
	}

	{
		error { reverse! { 3 1 2 3 } }
		equal { reverse! ref { 3 1 2 3 } } { 3 2 1 3 }
		equal { x: ref list { 1 2 3 } , reverse! x , x } list { 3 2 1 }
	}

	{
``	}

	group "concat" 
	"Joins two series values together."
	{
		arg `value1: First value (string, integer, block, uri) to concatenate`
		arg `value2: Second value to concatenate with the first`
		returns `result of concatenating the two values`
	}

	{
		equal { "abcd" .concat "cde" } "abcdcde"
		equal { concat { 1 2 3 4 } { 2 4 5 } } { 1 2 3 4 2 4 5 }
		equal { 123 .concat "abc" } "123abc"
		equal { https://example.com/ .concat "path" |type? } 'uri
	}

	{
``	}

	group "_++" 
	"Joins two values together, with behavior depending on types: concatenates strings, joins blocks, merges dictionaries, etc."
	{
		arg `value1: First value (string, block, dict, etc.)`
		arg `value2: Second value to join`
		returns `result of joining the values, type depends on input types`
	}

	{
		equal { "A" ++ "b" } "Ab"
		equal { "A" ++ 1 } "A1"
		equal { { 1 2 } ++ { 3 4 } } { 1 2 3 4 }
		equal { dict { "a" 1 } | ++ { "b" 2 } } dict { "a" 1 "b" 2 }
		equal { dict { "a" 1 } | ++ dict { "b" 2 } } dict { "a" 1 "b" 2 }
	}

	{
``	}

	group "union" 
	"Combines two collections, removing any duplicate values to create a union of all unique values."
	{
		arg `collection1: First block or list`
		arg `collection2: Second block or list`
		returns `a new collection containing all unique values from both collections`
	}

	{
		; equal { "abcd" .union "cde" } "abcde"
		equal { union { 1 2 3 4 } { 2 4 5 } |length? } 5 ; order is not certain
		equal { union list { 1 2 3 4 } list { 2 4 5 } |length? } 5 ; order is not certain
		equal { union { 8 2 } { 1 9 } |sort } { 1 2 8 9 }
		equal { union { 1 2 } { } |sort } { 1 2 }
		equal { union { } { 1 9 } |sort }  { 1 9 }
		equal { union { } { } } { }
		equal { union list { 1 2 } list { 1 2 3 4 } |sort } list { 1 2 3 4 }
		equal { union list { 1 2 } list { 1 } |sort } list { 1 2 }
		equal { union list { 1 2 } list { } |sort } list { 1 2 }
		equal { union list { } list { 1 2 } |sort } list { 1 2 }
		equal { union list { } list { } } list { }
	}

	{
``	}

	group "range" 
	"Creates a block containing all integers from the start value to the end value, inclusive."
	{
		arg `start: Integer starting value (inclusive)`
		arg `end: Integer ending value (inclusive)`
		returns `a block containing all integers from start to end, inclusive`
	}

	{
		equal { range 1 5 } { 1 2 3 4 5 }
		equal { range 5 10 } { 5 6 7 8 9 10 }
		equal { range -2 2 } { -2 -1 0 1 2 }
	}

	{
``	}

	group "is-empty" 
	"Checks if a collection is empty, returning true if empty and false otherwise."
	{
		arg `collection: String, block, dict, list, table, context or vector to check`
		returns `boolean true if the collection is empty, false otherwise`
	}

	{
		equal { { } .is-empty } true
		equal { dict { } |is-empty } true
		equal { table { 'a 'b } { } |is-empty } true
		equal { "abc" .is-empty } false
		equal { { 1 2 3 } .is-empty } false
	}

	{
``	}

	group "length?" 
	"Returns the number of elements in a collection."
	{
		arg `collection: String, block, dict, list, table, context or vector to measure`
		returns `integer count of elements in the collection`
	}

	{
		equal { { 1 2 3 } .length? } 3
		equal { length? "abcd" } 4
		equal { table { 'val } { 1 2 3 4 } |length? } 4
		equal { vector { 10 20 30 } |length? } 3
		equal { dict { "a" 1 "b" 2 } |length? } 2
	}

	{
``	}

	group "max-idx?" 
	"Returns the maximum valid index in a collection (length - 1)."
	{
		arg `collection: String, block, dict, list, table, context or vector to measure`
		returns `integer index of the last element in the collection`
	}

	{
		equal { { 1 2 3 } .max-idx? } 2
		equal { max-idx? "abcd" } 3
		equal { table { 'val } { 1 2 3 4 } |max-idx? } 3
		equal { vector { 10 20 30 } |max-idx? } 2
	}

	{
``	}

	group "keys" 
	"Extracts the keys from a dictionary or column names from a table as a block."
	{
		arg `collection: Dict or table to extract keys from`
		returns `block containing all keys from the dictionary or column names from the table`
	}

	{
		equal { dict { "a" 1 "b" 2 "c" 3 } |keys |length? } 3
		equal { table { "a" "b" "c" } { 1 2 3 } |keys |length? } 3
		; TODO -- doesn't work yet, .header? also has the same problem -- equal { table { 'a 'b 'c } { 1 2 3 } |keys } { 'a 'b 'c }
	}

	{
``	}

	group "_->" 
	"Accesses a value in a collection by index or key (0-based indexing for blocks and lists)."
	{
		arg `collection: Block, list, dict or other indexable collection`
		arg `index: Index or key to access`
		returns `value at the specified index or key`
	}

	{
		equal { { 23 34 45 } -> 1 } 34
		equal { { "a" "b" "c" } -> 0 } "a"
		equal { dict { "a" 1 "b" 2 } -> "b" } 2
	}

	{
``	}

	group "_<-" 
	"Accesses a value in a collection by index or key, with reversed argument order (0-based indexing for blocks and lists)."
	{
		arg `index: Index or key to access`
		arg `collection: Block, list, dict or other indexable collection`
		returns `value at the specified index or key`
	}

	{
		equal { 0 <- { 23 34 45 } } 23
		equal { 2 <- { "a" "b" "c" } } "c"
		equal { "a" <- dict { "a" 1 "b" 2 } } 1
	}

	{
``	}

	group "_<~" 
	"Accesses a value in a collection by index with reversed argument order (1-based indexing)."
	{
		arg `index: Index to access (1-based)`
		arg `collection: Block, list or other indexable collection`
		returns `value at the specified index`
	}

	{
		equal { 2 <~ { 23 34 45 } } 34
		equal { 1 <~ { "a" "b" "c" } } "a"
	}

	{
``	}

	group "_~>" 
	"Accesses a value in a collection by index (1-based indexing)."
	{
		arg `collection: Block, list or other indexable collection`
		arg `index: Index to access (0-based)`
		returns `value at the specified index`
	}

	{
		equal { { 23 34 45 } ~> 1 } 23
		equal { { "a" "b" "c" } ~> 1 } "a"
	}

	{
``	}

	group "intersection" 
	"Finds the common elements between two collections, returning only values that appear in both."
	{
		arg `collection1: First string, block or list`
		arg `collection2: Second string, block or list (same type as first)`
		returns `a new collection containing only values that appear in both input collections`
	}

	{
		equal { "abcd" .intersection "cde" } "cd"
		equal { intersection { 1 2 3 4 } { 2 4 5 } } { 2 4 }
		equal { intersection { 1 3 5 6 } { 2 3 4 5 } } { 3 5 }
		equal { intersection { 1 2 3 } { } } {  }
		equal { intersection { } { 2 3 4  } } { }
		equal { intersection { 1 2 3 } { 4 5 6 } } { }
		equal { intersection { } { } } { }
		equal { intersection list { 1 3 5 6 } list { 2 3 4 5 } } list { 3 5 }
		equal { intersection list { 1 2 3 } list { } } list {  }
		equal { intersection list { } list { 2 3 4 } } list { }
		equal { intersection list { 1 2 3 } list { 4 5 6 } } list { }
		equal { intersection list { } list { } } list { }
	}

	{
``	}

	group "intersection\\by" 
	"Finds the intersection of two collections using a custom comparison function to determine matching elements."
	{
		arg `collection1: First string or block`
		arg `collection2: Second string or block`
		arg `comparator: Function that takes two arguments and returns a truthy value if they should be considered matching`
		returns `a new collection containing values from the first collection that match with values from the second collection according to the comparator`
	}

	{
		equal { intersection\by "foobar" "fbx" fn { a b } { a .contains b } } "fb"
		equal { intersection\by "fooBar" "Fbx" fn { a b } { a .lower .contains lower b } } "fB"
		equal { intersection\by { "foo" 33 } { 33 33 } fn { a b } { a .contains b } } { 33 }
		equal { intersection\by { "foo" "bar" 33 } { 42 } fn { a b } { map a { .type? } |contains b .type? } } { 33 }
		equal { intersection\by { { "foo" x } { "bar" y } } { { "bar" z } } fn { a b } { map a { .first } |contains first b } } { { "bar" y } }
	}

	{
``	}

	group "difference" 
	"Creates a new collection containing elements from the first collection that are not present in the second collection."
	{
		arg `collection1: First string, block or list`
		arg `collection2: Second string, block or list (same type as first)`
		returns `a new collection containing values from the first collection that do not appear in the second collection`
	}

	{
		equal { "abcde" .difference "cde" } "ab"
		equal { difference { 1 2 3 4 } { 2 4 } } { 1 3 }
		equal { difference list { "Bob" "Sal" "Joe" } list { "Joe" } } list { "Bob" "Sal" }
		equal { difference "abc" "bc" } "a"
		equal { difference "abc" "abc" } ""
		equal { difference "abc" "" } "abc"
		equal { difference "" "" } ""
		equal { difference { 1 3 5 6 } { 2 3 4 5 } } { 1 6 }
		equal { difference { 1 2 3 } {  } } { 1 2 3 }
		equal { difference { } { 2 3 4  } } { }
		equal { difference { } { } } { }
		equal { difference list { 1 3 5 6 } list { 2 3 4 5 } } list { 1 6 }
		equal { difference list { 1 2 3 } list {  } } list { 1 2 3 }
		equal { difference list { } list { 2 3 4 } } list { }
		equal { difference list { } list { } } list { }
	}

	{
``	}

	group "transpose" 
	"Transposes a matrix (block of blocks), converting rows to columns and columns to rows."
	{
		arg `matrix: Block of blocks representing a matrix`
		returns `transposed matrix (rows become columns and columns become rows)`
	}

	{
		equal { { { 1 2 3 } { 4 5 6 } } .transpose } { { 1 4 } { 2 5 } { 3 6 } }
		equal { { { 1 4 } { 2 5 } { 3 6 } } .transpose } { { 1 2 3 } { 4 5 6 } }
	}

	{
``	}

	group "zip" 
	"Combines two same-size collections into a block of pairs, where each pair contains corresponding elements from both collections."
	{
		arg `collection1: First block or list`
		arg `collection2: Second block or list (must be same length as first)`
		returns `a block of blocks, where each inner block contains paired elements from both collections`
	}

	{
		equal { zip { 1 2 3 } { "a" "b" "c" } } { { 1 "a" } { 2 "b" } { 3 "c" } }
		equal { zip { 1 2 } { 10 20 } } { { 1 10 } { 2 20 } }
		equal { zip list { 1 2 3 } list { "a" "b" "c" } } { { 1 "a" } { 2 "b" } { 3 "c" } }
		equal { try { zip { 1 2 3 } { "a" "b" } } |type? } 'error
		equal { try { zip { } { } } |type? } 'error
	}

	{
``	}

	group "remove-last!" 
	"Removes the last element from a block in-place and returns the modified block."
	{
		arg `word: Word referring to a block to modify`
		returns `the modified block with the last element removed`
	}

	{
		equal { var 'x ref { 1 2 3 4 } remove-last! 'x x } { 1 2 3 }
		equal { var 'x ref { 1 2 3 4 } remove-last! 'x } { 1 2 3 }
	}

	{
``	}

	group "append!" 
	"Appends a value to a block, list or string in-place and returns the modified collection."
	{
		arg `value: Value to append`
		arg `word: Word referring to a block, list or string to modify`
		returns `the modified collection with the value appended`
	}

	{
		; TODO equal { x: ref { 1 2 3 } append! { 4 } x , x } { 1 2 3 4 }
		equal { var 'x ref { 1 2 3 } append! 4 'x , x } { 1 2 3 4 }
		equal { var 's "hello" append! " world" 's , s } "hello world"
	}

	{
``	}

	group "update!" 
	"Updates the value at a specific index in a block or list in-place and returns the modified collection (0-based indexing)."
	{
		arg `collection: Reference to a block or list to modify`
		arg `index: Index of the element to change (0-based)`
		arg `value: New value to set at the specified index`
		returns `the modified collection with the value changed at the specified index`
	}

	{
		equal { x: ref { 1 2 3 } update! x 1 222 , x } { 1 222 3 }
		equal { x: ref list { "a" "b" "c" } update! x 0 "X" , x } list { "X" "b" "c" }
		equal { x: ref { 10 20 30 } update! x 2 99 , x } { 10 20 99 }
	}

	{
``	}

	group "update\\with!" 
	"Updates the value at a specific index by evaluating a code block with the current value injected and storing the result (0-based indexing)."
	{
		arg `collection: Reference to a block or list to modify`
		arg `index: Index of the element to transform (0-based)`
		arg `transform: Block of code that receives the current value and returns the new value`
		returns `the modified collection with the value at the index transformed by the code block`
	}

	{
		equal { x: ref { 10 20 30 } update\with! x 1 { * 2 } , x } { 10 40 30 }
		equal { x: ref { 1 2 3 } update\with! x 0 { + 100 } , x } { 101 2 3 }
		; equal { x: ref list { 5 10 15 } update\with! x 2 { / 3 } , x } list { 5 10 5 }
		equal { x: ref { "a" "b" "c" } update\with! x 1 { .concat "!" } , x } { "a" "b!" "c" }
	}

	{
``	}

	group "update\\pos!" 
	"Updates the value at a specific position in a block or list in-place and returns the modified collection (1-based indexing)."
	{
		arg `collection: Reference to a block or list to modify`
		arg `position: Position of the element to change (1-based)`
		arg `value: New value to set at the specified position`
		returns `the modified collection with the value changed at the specified position`
	}

	{
		equal { x: ref { 1 2 3 } update\pos! x 2 222 , x } { 1 222 3 }
		equal { x: ref list { "a" "b" "c" } update\pos! x 1 "X" , x } list { "X" "b" "c" }
		equal { x: ref { 10 20 30 } update\pos! x 3 99 , x } { 10 20 99 }
	}

	{
``	}

	group "append\\many!" 
	"Appends all values from a block to a collection (block, list or string) in-place and returns the modified collection."
	{
		arg `values: Block of values to append`
		arg `word: Word referring to a block, list or string to modify`
		returns `the modified collection with all values from the block appended`
	}

	{
		equal { var 'x ref { 1 2 3 } append\many! { 4 5 6 } 'x , x } { 1 2 3 4 5 6 }
		equal { var 'x ref { 1 2 } append\many! { 3 4 5 6 } 'x , x } { 1 2 3 4 5 6 }
		equal { var 's "hello" append\many! { " " "world" "!" } 's , s } "hello world!"
		equal { var 'l ref list { 10 20 } append\many! { 30 40 } 'l , l } list { 10 20 30 40 }
	}

	{
``	}

	group "peek" 
	"Returns the current value at a block's cursor position without advancing the cursor."
	{
		arg `block: Block to peek at`
		returns `the current value at the block's cursor position without advancing the cursor`
	}

	{
		equal { x: { 1 2 3 } peek x } 1
	}

	{
``	}

	group "pop" 
	"Returns the current value at a block's cursor position and advances the cursor."
	{
		arg `block: Block to pop from`
		returns `the current value at the block's cursor position, advancing the cursor`
	}

	{
		equal { x: { 1 2 3 } pop x } 1
	}

	{
``	}

	group "pos" 
	"Returns the current cursor position in a block."
	{
		arg `block: Block to get position from`
		returns `the current cursor position in the block`
	}

	{
		equal { x: { 1 2 3 } pos x } 0
		equal { x: { 1 2 3 } pos next x } 1
	}

	{
``	}

	group "next" 
	"Advances the cursor position in a block and returns the block."
	{
		arg `block: Block to advance cursor in`
		returns `the block with its cursor advanced to the next position`
	}

	{
		equal { x: { 11 22 33 } peek next next x } 33
	}

	{
``	}

	group "at" 
	"Sets the cursor position in a block to the specified index and returns the block."
	{
		arg `block: Block to set cursor position in`
		arg `position: Integer position to set the cursor to (0-based)`
		returns `the block with its cursor set to the specified position`
	}

	{
		equal { { 1 2 3 4 5 } .at 0 |peek } 1
		equal { { 1 2 3 4 5 } .at 2 |peek } 3
		equal { { 1 2 3 4 5 } .at 4 |peek } 5
		equal { x: { 10 20 30 } at x 1 |pos } 1
		equal { { "a" "b" "c" } .at 0 |pop } "a"
	}

	{
``	}

	group "evals" 
	"Takes a block of Rye values and evaluates each value or expression."
	{
		arg `block-or-word: Block of expressions to evaluate, or a word to resolve`
		returns `block of evaluated results (for a block input) or the resolved word value`
	}

	{
		equal { x: 1 y: 2 evals { x y } } { 1 2 }
		equal { x: 1 y: 2 evals { 1 y } } { 1 2 }
		equal { x: 1 y: 2 try { evals { z y } } |type? } 'error
	}

	{
``	}

	group "evals\\with" 
	"Evaluate a block with injecting the first argument."
	{
		arg `value: Value injected into each expression`
		arg `block: Block of expressions to evaluate`
		returns `block of evaluated results`
	}

	{
		equal { x: 1 y: 2 evals\with 10 { + x , * y } } { 11 20 }
		equal { x: 1 y: 2 evals\with 100 { + 10 , * 8.9 } } { 110 890.0 }
	}

	{
``	}

}

section "Vector " "Vector operations" {
	group "vector" 
	"Creates a vector from a block of numbers."
	{
		arg `block: block of numbers to convert to a vector`
		returns `vector object`
	}

	{
		equal { vector [ 1 2 3 ] |type? } 'vector
	}

	{
``	}

	group "normalize" 
	"Calculates the L2 norm (Euclidean length) of a vector."
	{
		arg `vector: vector object to normalize`
		returns `decimal representing the L2 norm (Euclidean length) of the vector`
	}

	{
		equal { vector [ 3 4 ] |normalize } 5.0
	}

	{
``	}

	group "std-deviation" 
	"Calculates the standard deviation of a vector's elements."
	{
		arg `vector: vector object`
		returns `decimal representing the standard deviation of the vector elements`
	}

	{
		equal { vector [ 1 2 3 4 5 ] |std-deviation |math/round 2 } 1.58
	}

	{
``	}

	group "cosine-similarity" 
	"Calculates the cosine similarity between two vectors."
	{
		arg `vector1: first vector object`
		arg `vector2: second vector object`
		returns `decimal representing the cosine similarity between the two vectors`
	}

	{
		equal { cosine-similarity vector [ 1 0 ] vector [ 0 1 ] } 0.0
		equal { cosine-similarity vector [ 1 1 ] vector [ 1 1 ] } 1.0
	}

	{
``	}

	group "correlation" 
	"Calculates the correlation coefficient between two vectors."
	{
		arg `vector1: first vector object`
		arg `vector2: second vector object`
		returns `decimal representing the correlation coefficient between the two vectors`
	}

	{
		equal { correlation vector [ 1 2 3 4 5 ] vector [ 1 2 3 4 5 ] } 1.0
		equal { correlation vector [ 1 2 3 4 5 ] vector [ 5 4 3 2 1 ] } -1.0
	}

	{
``	}

	group "dot-product" 
	"Calculates the dot product between two vectors."
	{
		arg `vector1: first vector object`
		arg `vector2: second vector object`
		returns `decimal representing the dot product of the two vectors`
	}

	{
		equal { dot-product vector [ 1 2 3 ] vector [ 4 5 6 ] } 32.0
	}

	{
``	}

	group "euclidean-distance" 
	"Calculates the Euclidean distance between two vectors. Useful for K-Means clustering."
	{
		arg `vector1: first vector object`
		arg `vector2: second vector object`
		returns `decimal representing the Euclidean distance between the two vectors`
	}

	{
		equal { euclidean-distance vector [ 0 0 ] vector [ 3 4 ] } 5.0
		equal { euclidean-distance vector [ 1 2 3 ] vector [ 1 2 3 ] } 0.0
	}

	{
``	}

	group "mean-vectors" 
	"Calculates the element-wise mean of multiple vectors. Useful for creating 'Master Anchors'."
	{
		arg `block: block of vectors to average`
		returns `new vector representing the element-wise mean of all input vectors`
	}

	{
		equal { mean-vectors [ vector [ 1 2 ] vector [ 3 4 ] ] |to-block } { 2.0 3.0 }
	}

	{
``	}

	group "unit-vector" 
	"Returns a new normalized vector (length = 1). Essential for consistent dot products and overlays."
	{
		arg `vector: vector object to normalize`
		returns `new vector with length 1 (unit vector)`
	}

	{
		equal { vector [ 3 4 ] |unit-vector |normalize } 1.0
	}

	{
``	}

	group "project-vector" 
	"Projects vector onto another vector. Answers: 'How much of this vector is in the direction of another?'"
	{
		arg `vector1: vector to project`
		arg `vector2: vector to project onto`
		returns `new vector representing the projection of vector1 onto vector2`
	}

	{
		equal { vector [ 3 4 ] |project-vector vector [ 1 0 ] |to-block } { 3.0 0.0 }
	}

	{
``	}

	group "reject-vector" 
	"Removes projection from vector. Use this to 'subtract' a concept direction from a vector."
	{
		arg `vector1: vector to reject from`
		arg `vector2: vector representing the direction to remove`
		returns `new vector with the projection onto vector2 removed`
	}

	{
		equal { vector [ 3 4 ] |reject-vector vector [ 1 0 ] |to-block } { 0.0 4.0 }
	}

	{
``	}

}

section "Types and Kinds " "" {
	group "to-integer" 
	"Tries to change a Rye value (like string) to integer."
	{
		arg `value: String or decimal value to convert to an integer`
		returns `An integer value`
	}

	{
		equal { to-integer "1234" } 1234
		; equal { to-integer "123.4" } 123
		; equal { to-integer "123.6" } 123
		; equal { to-integer "123.4" } 123
		error { to-integer "abc" }
	}

	{
``	}

	group "to-decimal" 
	"Tries to change a Rye value (like string) to decimal."
	{
		arg `value: String value to convert to a decimal`
		returns `A decimal value`
	}

	{
		equal { to-decimal "123.4" } 123.4
		error { to-decimal "abc" }
	}

	{
``	}

	group "to-string" 
	"Tries to turn a Rye value to string."
	{
		arg `value: Any Rye value to convert to a string`
		returns `A string representation of the value`
	}

	{
		equal { to-string 'test } "test"
		equal { to-string 123 } "123"
		equal { to-string 123.4 } "123.400000"
		equal { to-string "test" } "test"
	}

	{
``	}

	group "to-uri" 
	"Tries to change Rye value to an URI."
	{
	}

	{
		equal   { to-uri "https://example.com" } https://example.com
		; error { to-uri "not-uri" }
	}

	{
``	}

	group "to-file" 
	"Tries to change Rye value to a file."
	{
	}

	{
		equal   { to-file "example.txt" } %example.txt
		equal { to-file 123 } %123
	}

	{
``	}

	group "to-char" 
	"Tries to turn a Rye value (like integer) to ascii character."
	{
		arg `value: Integer representing an ASCII code point`
		returns `A string containing the character corresponding to the ASCII code`
	}

	{
		equal { to-char 42 } "*"
		error { to-char "*" }
	}

	{
``	}

	group "to-block" 
	"Turns a List, Vector, or TableRow to a Block"
	{
		arg `value: List, Vector, or TableRow to convert to a block`
		returns `A block containing the same elements as the input`
	}

	{
		equal { list [ 1 2 3 ] |to-block |type? } 'block
		equal  { list [ 1 2 3 ] |to-block |first } 1
		equal { vector [ 1 2 3 ] |to-block } { 1.0 2.0 3.0 }
		equal { table { 'a 'b } { 1 2 3 4 } -> 1 |to-block } { 1 2 }
	}

	{
``	}

	group "to-context" 
	"Takes a Dict and returns a Context with same names and values."
	{
		arg `dict: Dict value to convert to a context`
		returns `A context with the same keys and values as the input dict`
	}

	{
		equal   { dict [ "a" 1 "b" 2 "c" 3 ] |to-context |type? } 'context
		; equal   { dict [ "a" 1 ] |to-context do\in { a } } '1
	}

	{
``	}

	group "to-word" 
	"Tries to change a Rye value to a word with same name."
	{
		arg `value: String or word-like value to convert to a word`
		returns `A word with the same name as the input value`
	}

	{
		equal { to-word "test" } 'test
		error { to-word 123 }
	}

	{
``	}

	group "is-string" 
	"Returns true if value is a string."
	{
		arg `value: Any Rye value to test`
		returns `Boolean true if the value is a string, false otherwise`
	}

	{
		equal   { is-string "test" } true
		equal   { is-string 'test } false
		equal   { is-string 123 } false
	}

	{
``	}

	group "is-integer" 
	"Returns true if value is an integer."
	{
		arg `value: Any Rye value to test`
		returns `Boolean true if the value is an integer, false otherwise`
	}

	{
		equal   { is-integer 123 } true
		equal   { is-integer 123.4 } false
		equal   { is-integer "123" } false
	}

	{
``	}

	group "is-decimal" 
	"Returns true if value is a decimal."
	{
		arg `value: Any Rye value to test`
		returns `Boolean true if the value is a decimal, false otherwise`
	}

	{
		equal   { is-decimal 123.4 } true
		equal   { is-decimal 123 } false
		equal   { is-decimal "123.4" } false
	}

	{
``	}

	group "is-number" 
	"Returns true if value is a number (integer or decimal)."
	{
		arg `value: Any Rye value to test`
		returns `Boolean true if the value is a number (integer or decimal), false otherwise`
	}

	{
		equal   { is-number 123 } true
		equal   { is-number 123.4 } true
		equal   { is-number "123" } false
	}

	{
``	}

	group "type?" 
	"Returns the type of Rye value as a word."
	{
		arg `value: Any Rye value to check the type of`
		returns `A word representing the type of the value`
	}

	{
		equal   { type? "test" } 'string
		equal   { type? 123.4 } 'decimal
	}

	{
``	}

	group "kind?" 
	"Returns the kind of Rye value as a word."
	{
		arg `value: Any Rye value to check the kind of`
		returns `A word representing the kind of the value`
	}

	{
		equal   { kind? %file } 'file-uri
	}

	{
``	}

	group "types?" 
	"Returns the types of Rye values in a block or table row as a block of words."
	{
		arg `collection: A block, table, or table row containing values to check types of`
		returns `A block of words representing the types of each value in the collection`
	}

	{
		equal   { types? { "test" 123 } } { string integer }
	}

	{
``	}

	group "dump" 
	"Returns (dumps) Rye code representing the object."
	{
		arg `value: Any Rye value to dump as code`
		returns `A string containing the Rye code representation of the value`
	}

	{
		equal { dump 123 } "123"
		equal { dump "string" } `"string"`
		equal { does { 1 } |dump } "fn { } { 1 }"
	}

	{
``	}

	group "mold" 
	"Turn value to it's string representation."
	{
		arg `value: Any Rye value to convert to a string representation`
		returns `A string containing the representation of the value`
	}

	{
		equal  { mold 123 } "123"
		equal  { mold { 123 } } "{ 123 }"
	}

	{
``	}

	group "mold\\nowrap" 
	"Turn value to it's string representation. Doesn't wrap the blocks"
	{
		arg `value: Any Rye value to convert to a string representation`
		returns `A string containing the representation of the value without block wrapping`
	}

	{
		equal  { mold\nowrap 123 } "123"
		equal  { mold\nowrap { 123 } } "123"
		equal  { mold\nowrap { 123 234 } } "123 234"
	}

	{
``	}

	group "assure-kind" 
	"Assuring kind."
	{
		arg `value: Dict to convert to a specific kind`
		arg `kind: Kind to convert the value to`
		returns `A new context of the specified kind`
	}

	{
		equal   { person: kind 'person { name: "" age: 0 } assure-kind dict { "name" "John" "age" 30 } person |type? } 'context
	}

	{
``	}

	group "method" 
	"Registers a method (generic function)."
	{
		arg `kind: Word representing the kind for which to register the function`
		arg `method: Word representing the method name`
		arg `function: Function to register for the kind and method`
		returns `The registered functionmethod <integer> <add> fn [ a b ] [ a + b ] // tagwords are temporary here`
	}

	{
		equal   { method 'integer 'add fn { a b } { a + b } |type? } 'function
	}

	{
``	}

	group "kind" 
	"Creates new kind."
	{
		arg `name: Word that will be the name of the kind`
		arg `spec: Block containing the specification for the kind`
		returns `A new kind object`
	}

	{
		equal   { kind 'person { name: "" age: 0 } |type? } 'kind
	}

	{
``	}

	group "secret" 
	"Creates a secret from a string."
	{
		arg `value: String value to convert to a secret`
		returns `A secret value that hides the string from casual inspection`
	}

	{
		equal { secret "password" |type? } 'secret
		equal { secret "password" |reveal } "password"
		error { secret 123 }
	}

	{
``	}

	group "reveal" 
	"Reveals the secret value."
	{
		arg `secret: Secret value to reveal`
		returns `The string value contained in the secret`
	}

	{
		equal { secret "password" |reveal } "password"
		equal { secret "test123" |reveal } "test123"
		error { reveal "not-a-secret" }
	}

	{
``	}

	group "lazy" 
	"Creates a lazy value from a block. The block will only be evaluated when forced with _!."
	{
		arg `value: Dict or context to convert`
		arg `kind: Kind to convert the value to`
		returns `A new context of the specified kind`
	}

	{
		; equal   { person: kind 'person { name: "" age: 0 } , { "name" "John" "age" 30 } .dict >> person |type? } 'ctx
	}

	{
``	}

}

section "Contexts " "Context related functions" {
	group "raw-context" 
	"Creates a completely isolated context with no parent, where only built-in functions are available."
	{
		arg `block: Block of expressions to evaluate in a new isolated context`
		returns `context object with the values defined in the block`
	}

	{
		equal { c: raw-context { x: 123 } c/x } 123
		equal { y: 123 try { c: raw-context { x: y } } |type? } 'error ; word not found y
		equal { try { c: raw-context { x: inc 10 } } |type? } 'error ; word not found inc
	}

	{
``	}

	group "isolate" 
	"Creates a context that can access the parent context during creation, but becomes isolated afterward."
	{
		arg `block: Block of expressions to evaluate in a temporary context`
		returns `context object with the values defined in the block, but isolated from parent contexts`
	}

	{
		equal { c: isolate { x: 123 } c/x } 123
		equal { y: 123 c: isolate { x: y } c/x } 123
		equal { c: isolate { x: inc 10 } c/x } 11
		; equal { y: 99 c: isolate { x: does { y } } try { c/x } |type? } 'error
		; equal { y: 99 c: isolate { t: ?try x: does { t { y } } } c/x |type? } 'error
	}

	{
``	}

	group "context" 
	"Creates a new context that maintains access to its parent context."
	{
		arg `block: Block of expressions to evaluate in a new context`
		returns `context object with the values defined in the block and access to parent context`
	}

	{
		equal { c: context { x: 123 } c/x } 123
		equal { y: 123 c: context { x: y } c/x } 123
		equal { c: context { x: inc 10 } c/x } 11
		equal { y: 123 c: context { x: does { y } } c/x } 123
	}

	{
``	}

	group "context\\pure" 
	"Creates a new context using Pure Context (PCtx) as parent, preventing access to regular context changes."
	{
		arg `block: Block of expressions to evaluate in a new pure context`
		returns `context object with the values defined in the block, using Pure Context as parent`
	}

	{
		equal { c: context\pure { x: 123 } c/x } 123
		; error { y: 123 c: context\pure { x: y } } ; y not accessible in pure context
		equal { c: context\pure { x: add 10 5 } c/x } 15
	}

	{
``	}

	group "private" 
	"Creates a temporary private context for evaluating expressions, returning the last value instead of the context."
	{
		arg `block: Block of expressions to evaluate in a private context`
		returns `the last value from evaluating the block (not the context itself)`
	}

	{
		equal { private { x: 123 } } 123
		equal { y: 123 private { x: y } } 123
		equal { private { x: inc 10 } } 11
		equal { y: 123 private { does { y } } :f f } 123
	}

	{
``	}

	group "private\\" 
	"Creates a documented private context for evaluating expressions, returning the last value instead of the context."
	{
		arg `doc: String containing documentation for the context`
		arg `block: Block of expressions to evaluate in a private context`
		returns `the last value from evaluating the block (not the context itself)`
	}

	{
		equal { private\ "what are we doing here" { x: 234 1000 + x } } 1234
	}

	{
``	}

	group "extends" 
	"Creates a new context that inherits from a specified parent context."
	{
		arg `parent: Context object to extend`
		arg `block: Block of expressions to evaluate in the new context`
		returns `new context object that inherits from the parent context`
	}

	{
		equal { ct: context { p: 123 } cn: extends ct { r: p + 234 } cn/r } 357
		; error { ct: context { p: 123 } cn: extends ct { r: p + 234 } cn/r }
	}

	{
``	}

	group "bind!" 
	"Binds a context to a parent context, allowing it to access the parent's values."
	{
		arg `child: Context object to be bound`
		arg `parent: Context object to bind to as parent`
		returns `the modified child context with its parent set to the specified parent context`
	}

	{
		equal { c: context { y: 123 } cc: bind! context { z: does { y + 234 } } c , cc/z } 357
	}

	{
``	}

	group "unbind" 
	"Removes the parent relationship from a context, making it a standalone context."
	{
		arg `ctx: Context object to unbind from its parent`
		returns `the modified context with no parent`
	}

	{
		equal { c: context { y: 123 } cc: bind! context { z: does { y + 234 } } c , unbind cc cc/z } 357
		; error { c: context { y: 123 } cc: bind! context { z: does { y + 234 } } c , dd: unbind cc dd/z }
	}

	{
``	}

	group "whereis" 
	"Searches for a word in current context and its parents, returns block with [ depth context ] where word was found."
	{
		arg `word: Word to look up in current or parent contexts`
		returns `block with [ depth context ] where depth is the number of parent hops (0 = current context) and context is where the word was found`
	}

	{
		equal { x: 123 whereis 'x |first } 0
		equal { x: 123 c: context { y: 456 } do\in c { whereis 'x } |first } 1
		equal { x: 123 c: context { y: 456 } do\in c { whereis 'y } |first } 0
	}

	{
``	}

	group "get" 
	"Gets the value of a word from current or parent contexts without calling it (similar to get-word ?word)."
	{
		arg `word: Word to look up in current or parent contexts`
		returns `the value bound to the word (including functions without calling them)`
	}

	{
		equal { x: 123 get 'x } 123
		equal { f: does { 101 } get 'f |type? } 'function
		equal { c: context { y: 456 } do\in c { get 'y } } 456
	}

	{
``	}

	group "current" 
	"Returns current context."
	{
	}

	{
		equal { c: context { var 'x 9999 , incr: fn\inside { } current { x:: inc x } } c/incr c/x } 10000
	}

	{
``	}

	group "parent?" 
	"Returns parent context of the current context."
	{
	}

	{
		equal { var 'y 99 c: context { incr: fn\inside { } parent? { y:: inc y } } c/incr y } 100
	}

	{
``	}

	group "parent\\of" 
	"Returns parent context of the current context."
	{
	}

	{
		equal { ct: context { p: 123 } parent\of ct |= current } true
	}

	{
``	}

	group "lc" 
	"Lists words in current context"
	{
		arg `none`
		returns `current context after printing the list of words to stdout`
	}

	{
	}

	{
``	}

	group "lc\\data" 
	"Returns words in current context as a block."
	{
		arg `none`
		returns `block of words defined in the current context`
	}

	{
		equal { x: 123 lc\data |type? } 'block
	}

	{
``	}

	group "lc\\data\\" 
	"Returns words in specified context as a block."
	{
		arg `ctx: Context to list words from`
		returns `block of words defined in the specified context`
	}

	{
		equal { c: context { x: 123 } lc\data\ c |type? } 'block
	}

	{
``	}

	group "lcp" 
	"Lists words in parent context"
	{
		arg `none`
		returns `current context after printing the parent context's words to stdout`
	}

	{
	}

	{
``	}

	group "lc\\" 
	"Lists words in current context with string filter, by type (word: 'function, 'builtin, 'context), or regex filter (native of kind 'regexp)"
	{
		arg `filter: String to filter by name, Word ('function, 'builtin, 'context) to filter by type, or regexp Native`
		returns `current context after printing filtered words to stdout`
	}

	{
	}

	{
``	}

	group "lcp\\" 
	"Lists words in parent context with string filter"
	{
		arg `filter: String to filter word names`
		returns `current context after printing filtered parent context words to stdout`
	}

	{
	}

	{
``	}

	group "cc" 
	"Change to context (pushes current context to stack for ccb)"
	{
		arg `ctx: Context to change to`
		returns `the new current context`
	}

	{
	}

	{
``	}

	group "ccp" 
	"Change to parent context (pushes current context to stack for ccb)"
	{
		arg `none`
		returns `the parent context (now current)`
	}

	{
	}

	{
``	}

	group "ccb" 
	"Change context back (pops from context stack)"
	{
		arg `none`
		returns `the previous context (now current)`
	}

	{
	}

	{
``	}

	group "mkcc" 
	"Make context with current as parent and change to it (pushes current context to stack for ccb)."
	{
		arg `word: Word to name the new context`
		returns `the new context (now current)`
	}

	{
	}

	{
``	}

	group "cc-stack-size" 
	"Returns the current size of the context navigation stack."
	{
		arg `none`
		returns `Integer with the current size of the context navigation stack`
	}

	{
	}

	{
``	}

	group "cc-clear-stack" 
	"Clears the context navigation stack (removes all stored previous contexts)."
	{
		arg `none`
		returns `Integer with the previous size of the stack before clearing`
	}

	{
	}

	{
``	}

	group "clone" 
	"Creates a copy of a context with the same state and parent relationship."
	{
		arg `ctx: Context object to clone`
		returns `a new context object that is a copy of the original context`
	}

	{
		equal { c: context { x: 123 y: 456 } cc: clone c cc/x } 123
		equal { c: context { x: 123 y: 456 } cc: clone c cc/y } 456
		equal { c: context { x:: 123 } cc: clone c do\inside cc { x:: 999 } c/x  } 123 ; original unchanged
		equal { c: context { x:: 123 } cc: clone c do\inside cc { x:: 999 } cc/x } 999 ; clone modified
	}

	{
``	}

	group "clone\\" 
	"Creates a copy of a context and evaluates a block of code inside the clone."
	{
		arg `ctx: Context object to clone`
		arg `block: Block of expressions to evaluate in the cloned context`
		returns `the cloned context with the block evaluated inside it`
	}

	{
		equal { c: context { x: 123 } cc: clone\ c { y: x + 100 } cc/y } 223
		; error { c: context { x:: 123 } cc: clone\ c { y:: x + 100 } c/y } 'error ; y not in original context
		equal { c: context { x:: 123 } cc: clone\ c { x:: 999 } c/x } 123 ; original unchanged
		equal { c: context { x:: 123 } cc: clone\ c { x:: 999 } cc/x } 999 ; clone modified
	}

	{
``	}

	group "clone\\deep" 
	"Creates a deep copy of a context with the same state and parent relationship, recursively copying all nested objects."
	{
		arg `ctx: Context object to deep clone`
		returns `a new context object that is a deep copy of the original context (including nested objects)`
	}

	{
		equal { c: context { x: [ 1 2 3 ] } cc: clone\deep c cc/x } [ 1 2 3 ]
		equal { c: context { x: [ 1 2 3 ] } cc: clone\deep c do\in cc { change\nth! ref x 1 999 } c/x -> 0 } 1 ; original unchanged
		equal { c: context { x: [ 1 2 3 ] } cc: clone\deep c do\in cc { change\nth! ref x 1 999 } cc/x -> 0 } 999 ; deep clone modified
	}

	{
``	}

}

section "Flow control " "Functions for conditional execution and branching logic" {
	group "if" 
	"Executes a block of code only if the condition is true, returning the result of the block or false."
	{
		arg `condition: Boolean value determining whether to execute the block`
		arg `block: Block of code to execute if condition is true`
		returns `result of the block if condition is true, false otherwise`
	}

	{
		equal  { if true { 222 } } 222
		equal  { if false { 333 } } false
		error  { if 1 { 222 } }
		error  { if 0 { 333 } }
	}

	{
``	}

	group "when" 
	"Conditionally executes an action block if a condition block evaluates to true, injecting the same value into both blocks and returning the value of the action block if the condition is truthy or the original value otherwise."
	{
		arg `value: Value to inject into both condition and action blocks`
		arg `condition: Block that evaluates to a truthy/falsy value with the injected value`
		arg `action: Block to execute if condition is truthy, with the injected value`
		returns `the value of the evaluated action block if condition is truthy or the original injected value if condition is falsy`
	}

	{
		equal  { 10 .when { > 5 } { + 3 } } 13
		equal  { 10 .when { < 5 } { + 3 } } 10
	}

	{
``	}

	group "^if" 
	"Conditional that sets the return flag when true, allowing early return from a function when the condition is a boolean."
	{
		arg `condition: Value to evaluate for truthiness`
		arg `block: Block of code to execute and return from if condition is truthy`
		returns `result of the block if condition is truthy (with return flag set), 0 otherwise`
	}

	{
		equal  { x: does { ^if true { 222 } 555 } x } 222
		equal  { x: does { ^if false { 333 } 444 } x } 444
	}

	{
``	}

	group "either" 
	"Executes one of two blocks based on a boolean condition, similar to if/else in other languages."
	{
		arg `condition: Boolean value determining which block to execute`
		arg `true_block: Block or value to return if condition is true`
		arg `false_block: Block or value to return if condition is false`
		returns `result of executing the true_block if condition is true, otherwise result of false_block`
	}

	{
		equal  { either true { 222 } { 333 } } 222
		equal  { either false { 222 } { 333 } } 333
		error  { either 1 { 222 } { 333 } }
		error  { either 0 { 222 } { 333 } }
	}

	{
``	}

	group "choose" 
	"Returns the first or second value from a block of two values based on a boolean condition."
	{
		arg `condition: Boolean value determining which value to return`
		arg `values: Block containing exactly two values`
		returns `first value if condition is true, second value if condition is false`
	}

	{
		equal  { choose true [ 1 -1 ] } 1
		equal  { choose false [ 1 -1 ] } -1
		equal  { choose 10 > 5 [ "yes" "no" ] } "yes"
		equal  { choose 3 < 2 [ "yes" "no" ] } "no"
		error  { choose 1 [ 1 -1 ] }
		error  { choose true [ 1 ] }
	}

	{
``	}

	group "switch" 
	"Pattern matching construct that executes a block of code corresponding to the first matching case value."
	{
		arg `value: Value to match against case values`
		arg `cases: Block containing case values and corresponding handler blocks`
		returns `result of executing the matching handler block, or the original value if no match`
	}

	{
		equal  { switch 101 { 101 { 111 } 202 { 222 } } } 111
		equal  { switch 202 { 101 { 111 } 202 { 222 } } } 222
	}

	{
``	}

	group "cases" 
	"Evaluates multiple condition-action pairs and applies all matching actions cumulatively to the initial value."
	{
		arg `initial: Initial value to be transformed by matching case blocks`
		arg `cases: Block containing condition blocks and corresponding transformation blocks`
		returns `cumulative result after applying all matching transformation blocks to the initial value`
	}

	{
		equal  { cases 0 { { 1 > 0 } { + 100 } { 2 > 1 } { + 1000 } } } 1100
		equal  { cases 0 { { 1 > 0 } { + 100 } { 2 < 1 } { + 1000 } } } 100
		equal  { cases 0 { { 1 < 0 } { + 100 } { 2 > 1 } { + 1000 } } } 1000
		equal  { cases 0 { { 1 < 0 } { + 100 } { 2 < 1 } { + 1000 } } } 0
		equal  { cases 1 { { 1 > 0 } { + 100 } { 2 < 1 } { + 1000 } _ { * 3 } } } 101
		equal  { cases 1 { { 1 < 0 } { + 100 } { 2 > 1 } { + 1000 } _ { * 3 } } } 1001
		equal  { cases 1 { { 1 < 0 } { + 100 } { 2 < 1 } { + 1000 } _ { * 3 } } } 3
	}

	{
``	}

}

section "Iteration " "Functions for iterating over collections and executing code repeatedly" {
	group "loop" 
	"Executes a block of code, builtin, or function a specified number of times, injecting the current iteration number (starting from 1)."
	{
		arg `count: Integer number of iterations to perform`
		arg `block: Block of code to execute on each iteration`
		returns `result of the last block execution`
	}

	{
		stdout { 3 .loop { prns "x" } } "x x x "
		equal  { 3 .loop { + 1 } } 3
		; equal  { 3 .loop { } } 3  ; TODO should pass the value
	}

	{
``	}

	group "produce" 
	"Executes a block of code a specified number of times, passing the result of each execution to the next iteration."
	{
		arg `count: Integer number of iterations to perform`
		arg `initial: Initial value to inject into the first block execution`
		arg `block: Block of code to execute on each iteration`
		returns `result of the last block execution`
	}

	{
		equal { produce 5 0 { + 3 } } 15
		equal { produce 3 ">" { ++ "x>" } } ">x>x>x>"
		equal { produce 3 { } { .concat "x" } } { "x" "x" "x" }
		equal { produce 3 { } { ::x .concat length? x } } { 0 1 2 }
		equal { produce 5 { 2 } { ::acc .last ::x * x |concat* acc } } { 2 4 16 256 65536 4294967296 }
	}

	{
``	}

	group "replicate" 
	"Executes a block of code a specified number of times and collects all results into a block."
	{
		arg `count: Integer number of times to execute the block`
		arg `block: Block of code to execute on each iteration`
		returns `Block containing the results of each execution`
	}

	{
		equal { replicate 5 { 10 } } { 10 10 10 10 10 }
		equal { replicate 3 { 1 + 2 } } { 3 3 3 }
		equal { replicate 0 { 10 } } { }
	}

	{
``	}

	group "replicate\\idx" 
	"Executes a block of code a specified number of times, injecting the current index (0-based), and collects all results into a block."
	{
		arg `count: Integer number of times to execute the block`
		arg `block: Block of code to execute on each iteration, with index (0-based) injected`
		returns `Block containing the results of each execution`
	}

	{
		equal { replicate\idx 5 { } } { 0 1 2 3 4 }
		equal { replicate\idx 3 { * 10 } } { 0 10 20 }
		equal { replicate\idx 0 { 10 } } { }
	}

	{
``	}

	group "produce\\while" 
	"Executes a block of code repeatedly while a condition is true, passing the result of each execution to the next iteration."
	{
		arg `condition: Block that evaluates to a boolean to determine when to stop iterating`
		arg `initial: Initial value to inject into the first block execution`
		arg `block: Block of code to execute on each iteration`
		returns `result of the last block execution before the condition became false`
	}

	{
		equal { var 'x 0 , produce\while { x < 100 } 1 { * 2 ::x } } 64
		stdout { var 'x 0 , produce\while { x < 100 } 1 { * 2 ::x .prns } } "2 4 8 16 32 64 128 "
	}

	{
``	}

	group "produce\\" 
	"Executes a block of code a specified number of times, updating an accumulator word with each iteration result."
	{
		arg `count: Integer number of iterations to perform`
		arg `initial: Initial value for the accumulator`
		arg `accumulator: Word to store the accumulator value`
		arg `block: Block of code to execute on each iteration`
		returns `final value of the accumulator word after all iterations`
	}

	{
		equal { produce\ 5 1 'acc { * acc , + 1 } } 1  ; Look at what we were trying to do here
	}

	{
``	}

	group "forever" 
	"Executes a block of code repeatedly until .return is called within the block."
	{
		arg `block: Block of code to execute repeatedly`
		returns `result of the block when .return is called`
	}

	{
		stdout { forever { "once" .prn .return } } "once"
		equal { forever { "once" .return } } "once"
	}

	{
``	}

	group "forever\\with" 
	"Accepts a value and a block, and executes the block repeatedly with the value until .return is called."
	{
		arg `value: Value to inject into the block on each iteration`
		arg `block: Block of code to execute repeatedly`
		returns `result of the block when .return is called`
	}

	{
		stdout { forever\with 1 { .prn .return } } "1"
		equal { var 'x 0 , forever\with 1 { + 5 ::x , if x > 5 { return x } } } 6
	}

	{
``	}

	group "for" 
	"Accepts a block of values and a block of code, builtin, or function, does the code for each of the values, injecting them."
	{
		arg `collection: Collection (Block, List, String, or Table) to iterate over`
		arg `code: Block, Builtin, or Function to execute for each value, injecting the value`
		returns `result of the last code execution`
	}

	{
		stdout { for { 1 2 3 } { prns "x" } } "x x x "
		stdout { { "a" "b" "c" } .for { .prns } } "a b c "
	}

	{
``	}

	group "for\\pos" 
	"Iterates over a collection with position tracking (1-based), setting a word to the current position and injecting each value."
	{
		arg `collection: Collection to iterate over`
		arg `word: Word to store the current position (1-based index)`
		arg `code: Block of code to execute for each value`
		returns `result of the last block execution`
	}

	{
		stdout { { "a" "b" "c" } .for\pos 'i { i .prns , .prns } } "1 a 2 b 3 c "
	}

	{
``	}

	group "for\\idx" 
	"Iterates over a collection with index tracking (0-based), setting a word to the current index and injecting each value."
	{
		arg `collection: Collection to iterate over`
		arg `word: Word to store the current index (0-based)`
		arg `code: Block of code to execute for each value`
		returns `result of the last block execution`
	}

	{
		stdout { { "a" "b" "c" } .for\idx 'i { i .prns , .prns } } "0 a 1 b 2 c "
	}

	{
``	}

	group "walk" 
	"Walks through a block, executing code that can modify the block on each iteration (useful for custom iteration patterns)."
	{
		arg `block: Block to walk through`
		arg `code: Block of code to execute, which should return a modified block`
		returns `result of the last block execution`
	}

	{
		stdout { walk { 1 2 3 } { .prns .rest } } "1 2 3  2 3  3  "
		equal { var 'x 0 , walk { 1 2 3 } { ::b .first + x ::x , b .rest } x } 6
	}

	{
``	}

	group "walk\\pos" 
	"Walks through a block with position tracking (1-based), setting a word to the current position and executing code that can modify the block."
	{
		arg `block: Block to walk through`
		arg `word: Word to store the current position (1-based index)`
		arg `code: Block of code to execute, which should return a modified block`
		returns `result of the last block execution`
	}

	{
		; stdout { walk\pos { 1 2 3 } 'i { .prns , i .prns , .rest } } "{ 1 2 3 } 1 { 2 3 } 2 { 3 } 3 "
	}

	{
``	}

	group "walk\\idx" 
	"Walks through a block with index tracking (0-based), setting a word to the current index and executing code that can modify the block."
	{
		arg `block: Block to walk through`
		arg `word: Word to store the current index (0-based)`
		arg `code: Block of code to execute, which should return a modified block`
		returns `result of the last block execution`
	}

	{
		stdout { walk\idx { 1 2 3 } 'i { .prns , i .prns , .rest } } "{ 1 2 3 } 0 { 2 3 } 1 { 3 } 2 "
	}

	{
``	}

	group "purge" 
	"Purges values from a series based on return of a injected code block."
	{
		arg `series: Block, List, String, or Table to purge from`
		arg `code: Block of code that returns true for values to remove`
		returns `modified series with matching values removed`
	}

	{
		equal { purge { 1 2 3 } { .is-even } } { 1 3 }
		equal { purge { } { .is-even } } { }
		equal { purge list { 1 2 3 } { .is-even } } list { 1 3 }
		equal { purge list { } { .is-even } } list { }
		equal { purge "1234" { .probe .to-integer .is-even } } { "1" "3" }
		equal { purge "" { .to-integer .is-even } } { }
	}

	{
``	}

	group "purge!" 
	"Purges values from a block stored in a word (modifying it in-place), returning the purged values."
	{
		arg `code: Block of code that returns true for values to remove`
		arg `word: Word referring to a Block to purge from (modified in-place)`
		returns `Block containing the purged values`
	}

	{
		equal { { 1 2 3 } ::x purge! { .is-even } 'x , x } { 1 3 }
	}

	{
``	}

	group "map" 
	"Maps values of a block to a new block by evaluating a block of code or function."
	{
	}

	{
		equal { map { 1 2 3 } { + 1 } } { 2 3 4 }
		equal { map { } { + 1 } } { }
		equal { map { "aaa" "bb" "c" } { .length? } } { 3 2 1 }
		equal { map list { "aaa" "bb" "c" } { .length? } } list { 3 2 1 }
		equal { map list { 3 4 5 6 } { .is-multiple-of 3 } } list { 1 0 0 1 }
		equal { map list { } { + 1 } } list { }
		; equal { map "abc" { + "-" } .join } "a-b-c-" ; TODO doesn't work, fix join
		equal { map "123" { .to-integer } } { 1 2 3 }
		equal { map "123" ?to-integer } { 1 2 3 }
		equal { map "" { + "-" } } { }
	}

	{
``	}

	group "map\\pos" 
	"Maps values of a block to a new block by evaluating a block of code."
	{
	}

	{
		equal { map\pos { 1 2 3 } 'i { + i } } { 2 4 6 }
		equal { map\pos { } 'i { + i } } { }
		equal { map\pos list { 1 2 3 } 'i { + i } } list { 2 4 6 }
		equal { map\pos list { } 'i { + i } } list { }
		equal { map\pos "abc" 'i { ++ i } } { "a1" "b2" "c3" }
		equal { map\pos "" 'i { + i } } { }
	}

	{
``	}

	group "map\\idx" 
	"Maps values of a block to a new block by evaluating a block of code."
	{
	}

	{
		equal { map\idx { 1 2 3 } 'i { + i } } { 1 3 5 }
		equal { map\idx { } 'i { + i } } { }
		equal { map\idx list { 1 2 3 } 'i { + i } } list { 1 3 5 }
		equal { map\idx list { } 'i { + i } } list { }
		equal { map\idx "abc" 'i { ++ i } } { "a0" "b1" "c2" }
		equal { map\idx "" 'i { + i } } { }
	}

	{
``	}

	group "reduce" 
	"Reduces values of a block to a single value by evaluating a block of code, using the first element as the initial accumulator."
	{
		arg `collection: Collection to reduce (must not be empty)`
		arg `accumulator: Word to store the accumulator value`
		arg `code: Block of code to execute for each value, receiving accumulator as context`
		returns `final accumulated value`
	}

	{
		equal { reduce { 1 2 3 } 'acc { + acc } } 6
		equal { reduce list { 1 2 3 } 'acc { + acc } } 6
		equal { reduce "abc" 'acc { ++ acc } } "cba"
		equal { try { reduce { } 'acc { + acc } } |type? } 'error
		equal { try { reduce list { } 'acc { + acc } } |type? } 'error
		equal { try { reduce "" 'acc { + acc } } |type? } 'error
	}

	{
``	}

	group "fold\\do" 
	"Reduces values of a block to a new block by evaluating a block of code ..."
	{
	}

	{
		equal { fold\do { 1 2 3 } 'acc 1 { + acc } } 7
		equal { fold\do { } 'acc 1 { + acc } } 1
		equal { fold\do list { 1 2 3 } 'acc 1 { + acc } } 7
		equal { fold\do list { } 'acc 1 { + acc } } 1
		equal { fold\do "abc" 'acc "123" { ++ acc } } "cba123"
		equal { fold\do "" 'acc "123" { + acc } } "123"
	}

	{
``	}

	group "fold" 
	"Reduces values of a block to a new block by evaluating a block of code ..."
	{
	}

	{
		equal { fold { 1 2 3 } 1 fn { v acc } { + acc } } 7
		equal { fold { } 1 fn { v acc } { + acc } } 1
		equal { fold list { 1 2 3 } 1 fn { v acc } { v + acc } } 7
	}

	{
``	}

	group "partition" 
	"Partitions a series by evaluating a block of code, grouping consecutive elements that return the same result."
	{
		arg `series: String, Block, or List to partition`
		arg `code: Block or Builtin that returns a value for grouping consecutive elements`
		returns `collection of partitions (each partition contains consecutive elements with the same result)`
	}

	{
		equal { partition { 1 2 3 4 } { > 2 } } { { 1 2 } { 3 4 } }
		equal { partition { "a" "b" 1 "c" "d" } { .is-integer } } { { "a" "b" } { 1 } { "c" "d" } }
		equal { partition { "a" "b" 1 "c" "d" } ?is-integer } { { "a" "b" } { 1 } { "c" "d" } }
		equal { partition { } { > 2 } } { { } }
		equal { partition list { 1 2 3 4 } { > 2 } } list evals { list { 1 2 } list { 3 4 } }
		equal { partition list { "a" "b" 1 "c" "d" } ?is-integer } list evals { list { "a" "b" } list { 1 } list { "c" "d" } }
		equal { partition list { } { > 2 } } list evals { list { } }
		equal { partition "aaabbccc" { , } } list { "aaa" "bb" "ccc" }
		equal { partition "" { , } } list { "" }
		equal { partition "aaabbccc" ?is-string } list { "aaabbccc" }
	}

	{
``	}

	group "group" 
	"Groups a block or list of values by a key generated from a code block (keys must be strings)."
	{
		arg `series: Block or List to group`
		arg `code: Block or Builtin that returns a string key for grouping`
		returns `Dict with string keys and List values containing grouped elements`
	}

	{
		; Equality for dicts doesn't yet work consistently
		;equal { { "Anne" "Mitch" "Anya" } .group { .first } } dict evals { "A" list { "Anne" "Anya" } "M" list { "Mitch" } }
		;equal { { "Anne" "Mitch" "Anya" } .group ?first } dict evals { "A" list { "Anne" "Anya" } "M" list { "Mitch" } }
		;equal { { } .group { .first } } dict evals { }
		;equal { { "Anne" "Mitch" "Anya" } .list .group { .first } } dict evals { "A" list { "Anne" "Anya" } "M" list { "Mitch" } }
		;equal { { "Anne" "Mitch" "Anya" } .list .group ?first } dict evals { "A" list { "Anne" "Anya" } "M" list { "Mitch" } }
		equal { { } .list .group { .first } } dict evals { }
		equal { try { { 1 2 3 4 } .group { .is-even } } |type? } 'error ; TODO keys can only be string currently
	}

	{
``	}

	group "filter" 
	"Filters values from a seris based on return of a injected code block."
	{
	}

	{
		equal { filter { 1 2 3 4 } { .is-even } } { 2 4 }
		equal { filter { 1 2 3 4 } ?is-even } { 2 4 }
		equal { filter { } { .is-even } } { }
		equal { filter list { 1 2 3 4 } { .is-even } } list { 2 4 }
		equal { filter list { 1 2 3 4 } ?is-even } list { 2 4 }
		; equal { filter list { } { .is-even } } list { }
		; equal { filter "1234" { .to-integer .is-even } } { "2" "4" }
		; equal { filter "01234" ?to-integer } { "1" "2" "3" "4" }
		; equal { filter "" { .to-integer .is-even } } { }
	}

	{
``	}

	group "seek" 
	"Seek over a series until a Block of code returns True and return the value."
	{
		arg `series: Block, List, or String to search through`
		arg `code: Block or Builtin that returns true when the desired value is found`
		returns `first value for which the code returns true, error if none found`
	}

	{
		equal { seek { 1 2 3 4 } { .is-even } } 2
		equal { seek list { 1 2 3 4 } { .is-even } } 2
		equal { seek "1234" { .to-integer .is-even } } "2"
		equal { try { seek { 1 2 3 4 } { > 5 } } |type? } 'error
		equal { try { seek list { 1 2 3 4 } { > 5 } } |type? } 'error
		equal { try { seek "1234" { .to-integer > 5 } } |type? } 'error
	}

	{
``	}

	group "while" 
	"Executes a block of code repeatedly while a condition is true."
	{
		arg `condition: Block that evaluates to a boolean to determine whether to continue`
		arg `body: Block of code to execute repeatedly`
		returns `result of the last body execution`
	}

	{
		equal { var 'x 0 while { x < 5 } { x:: x + 1 } x } 5
		equal { var 'x 0 var 'y 0 while { x < 5 } { x:: x + 1 y:: y + x } y } 15
	}

	{
``	}

	group "until" 
	"Executes a block of code repeatedly until a condition becomes true. Executes the body at least once before checking condition (do-until loop)."
	{
		arg `body: Block of code to execute repeatedly (executed at least once)`
		arg `condition: Block that evaluates to a boolean to determine when to stop`
		returns `result of the last body execution`
	}

	{
		equal { var 'x 5 until { x = 0 } { x:: x - 1 } x } 0
		equal { var 'x 10 var 'y 0 until { x = 5 } { x:: x - 1 y:: y + x } y } 35
		equal { var 'x 3 until { x < 1 } { x:: x - 1 } x } 0
		equal { var 'x 0 until { x > 0 } { x:: x + 1 } x } 1
	}

	{
``	}

	group "for\\" 
	"Iterates over a collection, setting a word to each value. Works with lists, blocks, and strings."
	{
		arg `collection: String, Block, List, or other Collection to iterate over`
		arg `word: Word to store each value during iteration`
		arg `block: Block of code to execute for each value`
		returns `result of the last block execution`
	}

	{
		stdout { { 1 2 3 } .for\ 'x { x .prns } } "1 2 3 "
		stdout { list { 10 20 30 } |for\ 'val { val .prns } } "10 20 30 "
		stdout { "abc" .for\ 'ch { ch .prns } } "a b c "
	}

	{
``	}

	group "for\\kv" 
	"Iterates over a collection with separate key and value words. For dicts, uses actual keys and values. For other collections, uses indices as keys."
	{
		arg `collection: Dict, Block, List, or other Collection to iterate over`
		arg `keyWord: Word to store the key (or index for non-dict collections)`
		arg `valueWord: Word to store the value`
		arg `block: Block of code to execute for each key-value pair`
		returns `result of the last block execution`
	}

	{
		stdout { dict { "a" 1 "b" 2 } |for\kv 'k 'v { k .prns v .prns } } "a 1 b 2 "
		stdout { { 10 20 30 } .for\kv 'i 'v { i .prns v .prns } } "0 10 1 20 2 30 "
	}

	{
``	}

}

section "Functions " "functions that create functions" {
	group "var" 
	"Declares a word as a variable with the given value, allowing it to be modified. Returns the word for use with on-change."
	{
		arg `word: Tagword representing the variable name`
		arg `value: Initial value for the variable`
		returns `The initial value`
	}

	{
		equal { var 'x 10 x:: 20 x } 20
	}

	{
``	}

	group "does" 
	"Creates a function with no arguments that executes the given block when called."
	{
		arg `body: Block containing the function body code`
		returns `function object with no parameters`
	}

	{
		equal { does { 123 } |type? } 'function
		equal { x: does { 123 } x } 123
		equal { x: does { 1 + 2 } x } 3
	}

	{
``	}

	group "fn1" 
	"Creates a function that accepts one anonymous argument and executes the given block with that argument."
	{
		arg `body: Block containing the function body code`
		returns `function object that accepts one anonymous argument`
	}

	{
		equal { fn1 { .pass { } } |type? } 'function
		equal { x: fn1 { } , x 123 } 123
		equal { x: fn1 { .pass { } } , x 123 } 123
		equal { x: fn1 { + 1 } , x 123 } 124
	}

	{
``	}

	group "fn" 
	"Creates a function with named parameters specified in the first block and code in the second block."
	{
		arg `spec: Block containing parameter specifications`
		arg `body: Block containing the function body code`
		returns `function object with the specified parameters`
	}

	{
		equal { fn { } { } |type? } 'function
		equal { x: fn { } { 234 } , x } 234
		equal { x: fn { x } { x } , x 123 } 123
		equal { x: fn { x } { + 123 } , x 123 } 246
	}

	{
``	}

	group "fn\\spec?" 
	"Returns the argument specification block of a function."
	{
		arg `function: Function to get the argument spec from`
		returns `Block containing the function's parameter specification`
	}

	{
		equal { f: fn { x y } { x + y } , ?f .fn\spec? } { x y }
		equal { does { 1 } |fn\spec? } { }
	}

	{
``	}

	group "fn\\body?" 
	"Returns the body block of a function."
	{
		arg `function: Function to get the body from`
		returns `Block containing the function's body code`
	}

	{
		equal { f: fn { x y } { x + y } , ?f .fn\body? } { x + y }
		equal { does { 123 } |fn\body? } { 123 }
	}

	{
``	}

	group "pfn" 
	"Creates a pure function (no side effects allowed) with named parameters and code body."
	{
		arg `spec: Block containing parameter specifications`
		arg `body: Block containing the function body code`
		returns `pure function object with the specified parameters`
	}

	{
		equal { pfn { } { } |type? } 'function
		equal { x: pfn { x } { + 123 } , x 123 } 246
		; TODO -- it seems pure namespace not also has print and append! error { x: pfn { } { ?append! } , x 123 }
		; TODO -- it seems pure namespace not also has print and append! error { x: pfn { x } { .print } , x 123 }
	}

	{
``	}

	group "fn\\cc" 
	"Creates a function that captures the current context, allowing access to variables from the enclosing scope."
	{
		arg `spec: Block containing parameter specifications`
		arg `body: Block containing the function body code`
		returns `function object with the current context captured`
	}

	{
		equal { fn\cc { x } { x + y } |type? } 'function
		equal { y: 5 , f: fn\cc { x } { x + y } , f 3 } 8
	}

	{
``	}

	group "fn\\in" 
	"Creates a function with a specified parent context, allowing access to variables from that context."
	{
		arg `spec: Block containing parameter specifications`
		arg `context: Context object to use as parent context`
		arg `body: Block containing the function body code`
		returns `function object with the specified parent context`
	}

	{
		equal { ctx: context { y: 5 } , f: fn\in { x } ctx { x + y } , f 3 } 8
	}

	{
``	}

	group "fn\\inside" 
	"Creates a function that executes directly in the specified context rather than creating a new execution context."
	{
		arg `spec: Block containing parameter specifications`
		arg `context: Context object to execute the function in`
		arg `body: Block containing the function body code`
		returns `function object that executes directly in the specified context`
	}

	{
		equal { ctx: context { y: 5 } , f: fn\inside { x } ctx { x + y } , f 3 } 8
	}

	{
``	}

	group "closure" 
	"Creates a closure that captures the current context at creation time, preserving access to variables in that scope."
	{
		arg `spec: Block containing parameter specifications`
		arg `body: Block containing the function body code`
		returns `function object that captures the current context at creation time`
	}

	{
		equal { y: 5 , f: closure { x } { x + y } , f 3 } 8
		equal { mk-cntr: does { var 'c 0 , closure { } { inc! 'c } } cnt: mk-cntr , cnt + cnt + cnt } 6
	}

	{
``	}

	group "partial" 
	"Creates a partially applied function with specified arguments, using _ (void) for arguments to be filled later."
	{
		arg `func: Function or builtin to partially apply`
		arg `args: Block of arguments, with _ (void) for arguments to be filled later`
		returns `CurriedCaller object that can be called with the remaining arguments`
	}

	{
		equal { prepend-star: partial ?concat [ "* " _ ] , prepend-star "hello" } "* hello"
		equal { add-5: partial ?_+ [ _ 5 ] , add-5 10 } 15
		equal { fn-add: fn { x y } { x + y } , add-5: partial ?fn-add [ _ 5 ] , add-5 10 } 15
	}

	{
``	}

	group "apply" 
	"Applies a function or builtin to a block of arguments."
	{
		arg `function: Function or builtin to apply`
		arg `args: Block of arguments to pass to the function`
		returns `The result of applying the function to the arguments`
	}

	{
		equal { apply ?_+ { 12 23 } } 35
		equal { apply fn { x y } { x + y } { 5 10 } } 15
		equal { f: fn { x y } { x * y } , apply ?f { 7 6 } } 42
	}

	{
``	}

	group "on-change" 
	"Registers an observer block to be executed when a variable changes. Use with 'var' result."
	{
		arg `word: Word representing the variable to observe`
		arg `observer: Block containing code to execute when variable changes`
		returns `The observer block`
	}

	{
		equal { x: var 'counter 0 , on-change x { print "changed" } , counter:: 5 } 5
	}

	{
``	}

}

section "Other " "..." {
	group "change!" 
	"Searches for a word and changes it's value in-place. Only works on variables declared with var. If value changes returns true otherwise false"
	{
		arg `value: New value to assign to the word`
		arg `word: Word whose value should be changed`
		returns `Boolean true if the value changed, false if the new value is the same as the old value`
	}

	{
		equal   { var 'x 123 , change! 234 'x , x } 234
		equal   { a:: 123 change! 333 'a a } 333
		equal   { a:: 123 change! 124 'a } true
		equal   { a:: 123 change! 123 'a } false
	}

	{
``	}

	group "modify!" 
	"Searches for a word and modifies	 it's value in-place. Only works on variables declared with var. If value changes returns true otherwise false"
	{
		arg `value: New value to assign to the word`
		arg `word: Word whose value should be changed`
		returns `Boolean true if the value changed, false if the new value is the same as the old value, will replace change!`
	}

	{
		equal   { var 'x 123 , modify! 234 'x , x } 234
		equal   { a:: 123 modify! 333 'a a } 333
		equal   { a:: 123 modify! 124 'a } true
		equal   { a:: 123 modify! 123 'a } false
	}

	{
``	}

	group "set" 
	"Set word to value or words by deconstructing a block. Only works on variables declared with var."
	{
		arg `values: Value or block of values to assign to the word(s)`
		arg `words: Word or block of words to be set`
		returns `The value or block of values that was assigned`
	}

	{
		equal   { set { 123 234 } { a b }  b } 234
	}

	{
``	}

	group "unset!" 
	"Unset a word in current context, only meant to be used in console"
	{
		arg `word: Word to be unset from the current context`
		returns `Void value`
	}

	{
		equal   { x: 1 unset! 'x x: 2 } 2 ; otherwise would produce an error
	}

	{
``	}

	group "val" 
	"Returns value of the word in context"
	{
		arg `word: Word whose value should be retrieved`
		returns `The value associated with the word in the current context`
	}

	{
		equal   { x: 123 val 'x } 123
		equal   { x: 123 y: 'x val y } 123
	}

	{
``	}

	group "_<<" 
	"Converts a value to specific kind (R to L)"
	{
		arg `kind: Kind to convert the value to`
		arg `value: Dict or context to convert`
		returns `A new context of the specified kind`
	}

	{
		; TODO equal   { person: kind 'person { name: "" age: 0 } person << dict { "name" "John" "age" 30 } |type? } 'ctx
	}

	{
``	}

	group "_|" 
	"Pipeline operator that passes the value through unchanged (used with 'not' and other operations)."
	{
		arg `value: Any value to be passed through unchanged`
		returns `the original value (used in pipeline operations for explicit pass-through)`
	}

	{
		equal { 5 _| } 5
		equal { "hello" _| } "hello"
		equal { true _| } true
		equal { { 1 2 3 } _| } { 1 2 3 }
	}

	{
``	}

	group "save\\current" 
	"Saves current state of the program to a file."
	{
		arg `None`
		returns `Integer 1 on success`
	}

	{
		equal  { save\current |type? } 'integer
	}

	{
``	}

	group "save\\current\\secure" 
	"Saves current state of the program to a file with password protection."
	{
		arg `None`
		returns `Integer 1 on success`
	}

	{
		; equal  { save\current\secure |type? } 'integer
	}

	{
``	}

	group "doc!" 
	"Sets docstring of the current context."
	{
		arg `doc: String to set as the docstring for the current context`
		returns `Integer 1 on success`
	}

	{
		equal   { x: private { doc! "some doc" doc? } } "some doc"
	}

	{
``	}

	group "doc?" 
	"Gets docstring of the current context."
	{
		arg `None`
		returns `String containing the docstring of the current context`
	}

	{
		equal   { x: private { doc! "some doc" doc? } } "some doc"
	}

	{
``	}

	group "doc\\of?" 
	"Get docstring of the passed context."
	{
		arg `value: Function, builtin, or context to get the docstring from`
		returns `String containing the docstring of the provided value`
	}

	{
		equal   { x: context { doc! "some doc" } doc\of? x } "some doc"
	}

	{
``	}

	group "ref" 
	"Makes a value mutable instead of immutable"
	{
		arg `value: Value to make mutable`
		returns `A mutable reference to the value`
	}

	{
		equal   { is-ref ref { 1 2 3 } } true
		equal   { ref { 1 2 3 } |type? } 'block
		equal   { ref dict { "a" 1 } |type? } 'dict
		equal   { ref list { 1 2 3 } |type? } 'list
		equal   { ref "hello" |disarm |type? } 'string
		; TODO equal   { b: ref { 1 2 3 } , append! b 4 , deref b |length? } 4 ; mutable in-place append
	}

	{
``	}

	group "deref" 
	"Makes a value again immutable"
	{
		arg `value: Mutable reference to make immutable`
		returns `An immutable copy of the value`
	}

	{
		equal   { is-ref deref ref { 1 2 3 } } false
		equal   { deref ref { 1 2 3 } } { 1 2 3 }
		equal   { deref ref "hello" } "hello"
		equal   { deref ref list { 1 2 3 } |length? } 3
		equal   { ref dict { "a" 1 } |deref |type? } 'dict
	}

	{
``	}

	group "is-ref" 
	"Checks if a value is a mutable reference."
	{
		arg `value: Any value to check if it's a reference`
		returns `Integer 1 if the value is a reference, 0 otherwise`
	}

	{
		equal  { ref { } |is-ref } true
		equal  { { } |is-ref } false
		equal  { ref "hello" |is-ref } true
		equal  { "hello" |is-ref } false
		equal  { ref list { 1 2 3 } |is-ref } true
		equal  { 123 |is-ref } false
	}

	{
``	}

	group "dict" 
	"Constructs a Dict from the Block of key and value pairs."
	{
		arg `block: Block containing alternating keys and values`
		returns `A new Dict with the specified keys and values`
	}

	{
		equal { dict { "a" 123 } -> "a" } 123
		equal { dict { "name" "John" "age" 30 } -> "name" } "John"
		equal { dict { } |type? } 'dict
		equal { dict { "x" 1 "y" 2 "z" 3 } |length? } 3
		error { dict { 123 "value" } } ; integer keys should fail
		error { dict { { } "value" } } ; block keys should fail
		equal { dict { 'key "value" } -> "key" } "value" ; tagwords as keys
	}

	{
``	}

	group "change" 
	"Returns a new Dict with the specified key changed to the new value. Original dict is unchanged."
	{
		arg `dict: Dict to update`
		arg `key: String key to change`
		arg `value: New value for the key`
		returns `A new Dict with the key updated (original dict unchanged)`
	}

	{
		equal { dict { "a" 1 "b" 2 } |change "a" 99 -> "a" } 99
		equal { dict { "a" 1 "b" 2 } |change "c" 3 -> "c" } 3
		equal { d: dict { "x" 10 } , change d "x" 20 -> "x" } 20
	}

	{
``	}

	group "list" 
	"Constructs a List from the Block of values."
	{
		arg `block: Block containing values to put in the list`
		returns `A new List with the values from the block`
	}

	{
		equal { list { "a" 123 } -> 0 } "a"
		equal { list { 1 2 3 } |length? } 3
		equal { list { } |length? } 0
		equal { list { "hello" "world" } -> 1 } "world"
		equal { list { 1 2 3 } |type? } 'list
		equal { list { 1 2 3 } |first } 1
		equal { list { 1 2 3 } |last } 3
	}

	{
``	}

	group "file-uri//Import" 
	"Imports a file, loads and does it from script local path."
	{
		arg `uri: URI of the file to import and execute`
		returns `result of executing the imported file`
	}

	{
		; import file://test.rye  ; imports and executes test.rye
	}

	{
``	}

	group "file-uri//Import\\live" 
	"Imports a file, loads and does it from script local path."
	{
		arg `uri: URI of the file to import, execute, and watch for changes`
		returns `result of executing the imported file`
	}

	{
		; import\live file://test.rye  ; imports, executes, and watches test.rye for changes
	}

	{
``	}

	group "load" 
	"Loads a string into Rye values."
	{
		arg `source: String containing Rye code or URI of file to load`
		returns `Block containing the parsed Rye values`
	}

	{
		equal  { load " 1 2 3 " |third } 3
		equal  { load "{ 1 2 3 }" |first |third } 3
	}

	{
``	}

	group "file-uri//Load" 
	"Loads a string into Rye values."
	{
		arg `source: String containing Rye code or URI of file to load`
		returns `Block containing the parsed Rye values`
	}

	{
		; equal  { load " 1 2 3 " |third } 3
		; equal  { load "{ 1 2 3 }" |first |third } 3
	}

	{
``	}

	group "load\\mod" 
	"Loads a string into Rye values. During load it allows modification of words."
	{
		arg `source: String containing Rye code or URI of file to load with modification allowed`
		returns `Block containing the parsed Rye values`
	}

	{
		; load\mod file://modifiable.rye  ; loads file with word modification allowed
	}

	{
``	}

	group "load\\live" 
	"Loads a string into Rye values. During load it allows modification of words."
	{
		arg `source: String containing Rye code or URI of file to load with modification allowed and file watching`
		returns `Block containing the parsed Rye values`
	}

	{
		; load\live file://watched.rye  ; loads and watches file for changes
	}

	{
``	}

	group "load\\sig" 
	"Checks the signature, if OK then loads a string into Rye values."
	{
		arg `source: String containing signed Rye code to verify and load`
		returns `Block containing the parsed Rye values if signature is valid`
	}

	{
		; load\sig "signed-code"  ; loads only if signature is valid
	}

	{
``	}

	group "do" 
	"Takes a block of code and does (runs) it."
	{
		arg `block: Block of code to execute`
		returns `result of executing the block`
	}

	{
		equal  { do { 123 + 123 } } 246
		error  { do { 123 + } }
		equal  { do { _+ _+ 12 23 34 } } 69
		equal  { do { 12 * 23 |+ 34 } } 310
		equal  { do { ( 12 * 23 ) + 34 } } 310
		equal  { do { 12 * 23 | + 34 } } 310
		equal  { do { 12 * 23 :a + 34 } } 310
		equal  { do { 12 * 23 :a a + 34 } } 310
	}

	{
``	}

	group "with" 
	"Takes a value and a block of code. It does the code with the value injected."
	{
		arg `value: Value to inject into the block's execution context`
		arg `block: Block of code to execute with the injected value`
		returns `result of executing the block with the injected value`
	}

	{
		equal  { with 100 { + 11 } } 111
		equal  { with 100 { + 11 , * 3 } } 300
	}

	{
``	}

	group "do\\inside" 
	"Takes a Context and a Block. It Does a block inside a given Context."
	{
		arg `context: Context in which to execute the block`
		arg `block: Block of code to execute within the specified context`
		returns `result of executing the block within the given context`
	}

	{
		equal  { c: context { x: 100 } do\inside c { x * 9.99 } } 999.0
		equal  { c: context { x:: 100 } do\inside c { inc! 'x } } 101
		equal  { c: context { var 'x 100 } do\inside c { x:: 200 } c/x } 200
		equal  { c: context { x:: 100 } do\inside c { x:: 200 , x } } 200
	}

	{
``	}

	group "do\\in" 
	"Takes a Context and a Block. It Does a block in current context but with parent a given Context."
	{
		arg `context: Context to use as parent context during execution`
		arg `block: Block of code to execute in current context with the specified parent context`
		returns `result of executing the block with the modified parent context`
	}

	{
		equal  { c: context { x: 100 } do\in c { x * 9.99 } } 999.0
		equal  { c: context { x:: 100 } do\in c { inc! 'x } } 101
		equal  { c: context { x: 100 } do\in c { x:: 200 , x } } 200
		equal  { c: context { x: 100 } do\in c { x:: 200 } c/x } 100
	}

	{
``	}

	group "do\\inx" 
	"Takes a Context and a Block. It Does a block in current context but with parent a given Context."
	{
		arg `context: Context to use as parent context during execution`
		arg `block: Block of code to execute in current context with the specified parent context`
		returns `result of executing the block with the modified parent context`
	}

	{
		equal  { c: context { x: 100 } do\in c { x * 9.99 } } 999.0
		equal  { c: context { x:: 100 } do\in c { inc! 'x } } 101
		equal  { c: context { x: 100 } do\in c { x:: 200 , x } } 200
		equal  { c: context { x: 100 } do\in c { x:: 200 } c/x } 100
	}

	{
``	}

	group "return" 
	"Accepts one value and returns it."
	{
	}

	{
		equal { x: fn { } { return 101 202 } x } 101
	}

	{
``	}

	group "scmd" 
	"Execute a shell command and return its exit status code."
	{
	}

	{
		equal { scmd `echo "hello"` } 0
		equal { scmd `exit 1` } 1
		equal { scmd `exit 42` } 42
	}

	{
``	}

	group "scmd\\capture" 
	"Execute a shell command and capture the output, return it as string"
	{
	}

	{
		equal { scmd\capture `echo "hello"` } "hello\n"
	}

	{
``	}

	group "rye" 
	""
	{
	}

	{
		equal { rye .type? } 'native
	}

	{
``	}

	group "Rye-itself//History?" 
	"Returns a block of the last N lines from REPL history."
	{
		arg `n: Integer specifying how many history lines to return`
		returns `Block of strings containing the last N lines of REPL history`
	}

	{
		; equal { rye .history 5 |length? } 5
	}

	{
``	}

	group "defer" 
	"Registers a block of code to be executed when the current function exits or the program terminates."
	{
	}

	{
		equal { x:: 123 defer { x:: 345 } x } 123
		stdout { ff:: fn { } { var 'x 123 defer { print 234 } x } , ff } "234\n"
		equal { ff:: fn { } { x:: 123 defer { x:: 234 } x + 111 } , ff } 234 ; the result of defer expression is returned TODO, change this
	}

	{
``	}

	group "defer\\" 
	"Registers a block of code with an injected value to be executed when the current function exits or the program terminates. Works like 'with' but deferred."
	{
		arg `value: Value to inject into the deferred block`
		arg `block: Block to execute with the injected value when function exits`
		returns `Void value`
	}

	{
		equal { x:: 0 defer\ 42 { + 1 } x } 0
		stdout { ff:: fn { } { defer\ "hello" { .print } "done" } , ff } "hello\n"
	}

	{
``	}

	group "assert" 
	"Evaluates a block of code and asserts that its result equals the expected value. Returns the result if assertion passes, fails with error message if not."
	{
		arg `block: Block of code to evaluate`
		arg `expected: Expected result value`
		returns `The result value if assertion passes, error if it fails`
	}

	{
		equal  { assert { 1 + 2 } 3 } 3
		equal  { assert { "hello" } "hello" } "hello"
		error  { assert { 1 + 2 } 5 }
	}

	{
``	}

	group "assert\\display" 
	"Evaluates a block of code and displays the result. Prints the explanation in magenta followed by OK in green on success, or error message in red on failure. Does not fail - continues evaluation."
	{
		arg `explanation: String describing the test being performed`
		arg `block: Block of code to evaluate`
		arg `expected: Expected result value`
		returns `The result value (displays status but continues evaluation even on failure)`
	}

	{
		stdout { assert\display "check addition" { 1 + 2 } 3 } "\e[35mcheck addition\e[0m: \e[32mOK\e[0m\n"
		; stdout { assert\display "check addition" { 1 + 2 } 5 } "\e[35mcheck addition\e[0m: \e[31FAILED: expected `[Integer: 5]` but got `[Integer: 3]\e[0m\n"
	}

	{
``	}

	group "recur-if" 
	"Internal recursion control function. Resets function execution if condition > 0, otherwise returns result."
	{
		arg `condition: Integer value, if > 0 triggers recursion reset`
		returns `nil if recursion continues, ps.Res if recursion ends`
	}

	{
	}

	{
``	}

	group "recur-if\\1" 
	"Internal recursion control function for single-argument functions. Updates first argument and resets if condition > 0."
	{
		arg `condition: Integer value, if > 0 triggers recursion with updated argument`
		arg `arg1: New value for the first function argument during recursion`
		returns `nil if recursion continues, ps.Res if recursion ends`
	}

	{
	}

	{
``	}

	group "recur-if\\2" 
	"Internal recursion control function for two-argument functions. Updates both arguments and resets if condition > 0."
	{
		arg `condition: Integer value, if > 0 triggers recursion with updated arguments`
		arg `arg1: New value for the first function argument during recursion`
		arg `arg2: New value for the second function argument during recursion`
		returns `ps.Res (function result) regardless of condition`
	}

	{
	}

	{
``	}

	group "recur-if\\3" 
	"Internal recursion control function for three-argument functions. Updates all three arguments and resets if condition > 0."
	{
		arg `condition: Integer value, if > 0 triggers recursion with updated arguments`
		arg `arg1: New value for the first function argument during recursion`
		arg `arg2: New value for the second function argument during recursion`
		arg `arg3: New value for the third function argument during recursion`
		returns `ps.Res (function result) regardless of condition, nil if recursion continues`
	}

	{
	}

	{
``	}

}

section "Combinators " "Functions that combine other functions or control execution flow" {
	group "pass" 
	"Accepts a value and a block. It does the block, with value injected, and returns (passes on) the initial value."
	{
		arg `value: Any value that will be passed to the block and returned`
		arg `block: Block of code to execute with the value injected`
		returns `The original value, regardless of what the block returns`
	}

	{
		equal  { 101 .pass { 202 } } 101
		equal  { 101 .pass { 202 + 303 } } 101
	}

	{
``	}

	group "wrap" 
	"Executes a wrapper block before and after executing a main block, returning the result of the main block."
	{
		arg `wrapper: Block of code to execute before and after the main block`
		arg `block: Main block of code to execute between wrapper executions`
		returns `The result of the main block execution`
	}

	{
		stdout { wrap { prn "*" } { prn "x" } } "*x*"
	}

	{
``	}

	group "keep" 
	"Do the first block, then the second one but return the result of the first one."
	{
		arg `value: Value to be injected into both blocks`
		arg `block1: First block whose result will be returned`
		arg `block2: Second block to execute after the first one`
		returns `The result of the first block, ignoring the result of the second block`
	}

	{
		equal  { 20 .keep { + 202 } { + 101 } } 222
	}

	{
``	}

}

section "Printing " "Functions for displaying and formatting values" {
	group "prns" 
	"Prints a value followed by a space, returning the input value."
	{
		arg `value: Any value to print`
		returns `the input value (for chaining)`
	}

	{
		stdout { prns "xy" } "xy "
	}

	{
``	}

	group "prn" 
	"Prints a value without adding a newline, returning the input value."
	{
		arg `value: Any value to print`
		returns `the input value (for chaining)`
	}

	{
		stdout { prn "xy" } "xy"
	}

	{
``	}

	group "print" 
	"Prints a value followed by a newline, returning the input value."
	{
		arg `value: Any value to print`
		returns `the input value (for chaining)`
	}

	{
		stdout { print "xy" } "xy\n"
	}

	{
``	}

	group "print2" 
	"Prints two values separated by a space and followed by a newline, returning the second value."
	{
		arg `value1: First value to print`
		arg `value2: Second value to print`
		returns `the second input value`
	}

	{
		stdout { print2 "hello" "world" } "hello world\n"
	}

	{
``	}

	group "prn2" 
	"Prints two values separated by a space without adding a newline, returning the second value."
	{
		arg `value1: First value to print`
		arg `value2: Second value to print`
		returns `the second input value`
	}

	{
		stdout { prn2 "hello" "world" } "hello world"
	}

	{
``	}

	group "prns2" 
	"Prints two values separated by a space and followed by a space, returning the second value."
	{
		arg `value1: First value to print`
		arg `value2: Second value to print`
		returns `the second input value`
	}

	{
		stdout { prns2 "hello" "world" } "hello world "
	}

	{
``	}

	group "format" 
	"Formats a value according to Go's sprintf format specifiers, returning the formatted string."
	{
		arg `value: Value to format (string, integer, or decimal)`
		arg `format: String containing Go's sprintf format specifiers`
		returns `formatted string`
	}

	{
		equal { format 123 "num: %d" } "num: 123"
		equal { format "hello" "%s world" } "hello world"
	}

	{
``	}

	group "prnf" 
	"Formats a value according to Go's sprintf format specifiers and prints it without a newline, returning the input value."
	{
		arg `value: Value to format (string, integer, decimal, or block of multiple values)`
		arg `format: String containing Go's sprintf format specifiers`
		returns `the input value (for chaining)`
	}

	{
		stdout { prnf 123 "num: %d" } "num: 123"
		stdout { prnf { "hello" 42 } "%s is %d" } "hello is 42"
	}

	{
``	}

	group "printf" 
	"Formats a value according to Go's sprintf format specifiers and prints it followed by a newline, returning the input value."
	{
		arg `value: Value to format (string, integer, decimal, or block of multiple values)`
		arg `format: String containing Go's sprintf format specifiers`
		returns `the input value (for chaining)`
	}

	{
		stdout { printf 123 "num: %d" } "num: 123\n"
		stdout { printf { "hello" 42 } "%s is %d" } "hello is 42\n"
	}

	{
``	}

	group "embed" 
	"Embeds a value into a string or URI by replacing {} placeholder with the string representation of the value."
	{
		arg `value: Value to embed`
		arg `template: String or URI containing {} as a placeholder`
		returns `string or URI with the placeholder replaced by the value`
	}

	{
		equal { embed 101 "val {}" } "val 101"
		equal { embed "world" "hello {}" } "hello world"
	}

	{
``	}

	group "prnv" 
	"Embeds a value into a string by replacing {} placeholder and prints it without a newline, returning the input value."
	{
		arg `value: Value to embed`
		arg `template: String containing {} as a placeholder`
		returns `the input value (for chaining)`
	}

	{
		stdout { prnv 101 "val {}" } "val 101"
	}

	{
``	}

	group "printv" 
	"Embeds a value into a string by replacing {} placeholder and prints it followed by a newline, returning the input value."
	{
		arg `value: Value to embed`
		arg `template: String containing {} as a placeholder`
		returns `the input value (for chaining)`
	}

	{
		stdout { printv 101 "val {}" } "val 101\n"
	}

	{
``	}

	group "print\\ssv" 
	"Prints a block of values as space-separated values followed by a newline, returning the input block."
	{
		arg `block: Block of values to format as space-separated values`
		returns `the input block (for chaining)`
	}

	{
		stdout { print\ssv { 101 "asd" } } "101 asd\n"
	}

	{
``	}

	group "print\\csv" 
	"Prints a block of values as comma-separated values followed by a newline, returning the input block."
	{
		arg `block: Block of values to format as comma-separated values`
		returns `the input block (for chaining)`
	}

	{
		stdout { print\csv { 101 "asd" } } "101,asd\n"
	}

	{
``	}

	group "probe" 
	"Prints detailed type and value information about a value, followed by a newline, returning the input value."
	{
		arg `value: Any value to inspect`
		returns `the input value (for chaining)`
	}

	{
		stdout { probe 101 } "[Integer: 101]\n"
	}

	{
``	}

	group "probe\\" 
	"Prints a prefix string followed by detailed type and value information about a value, followed by a newline, returning the input value."
	{
		arg `value: Any value to inspect`
		arg `prefix: String to print before the probed value`
		returns `the input value (for chaining)`
	}

	{
		stdout { probe\ 101 "value:" } "value: [Integer: 101]\n"
	}

	{
``	}

	group "inspect" 
	"Returns a string containing detailed type and value information about a value."
	{
		arg `value: Any value to inspect`
		returns `string containing detailed type and value information`
	}

	{
		equal { inspect 101 } "[Integer: 101]"
	}

	{
``	}

	group "esc" 
	"Creates an ANSI escape sequence by prepending the escape character (\\033) to the input string."
	{
		arg `sequence: String to append to the escape character`
		returns `string with escape sequence`
	}

	{
		; equal { esc "[33m" } "\033[33m"   ; we can't represent hex or octal in strings yet
	}

	{
``	}

	group "esc-val" 
	"Creates an ANSI escape sequence with an embedded value by replacing {} placeholder and prepending the escape character (\\033)."
	{
		arg `value: Value to embed`
		arg `template: String containing {} as a placeholder`
		returns `string with escape sequence and embedded value`
	}

	{
		; equal { esc-val "[33m" "Error" } "\033[33mError"  ; we can't represent hex or octal in strings yet
	}

	{
``	}

	group "display" 
	"Interactively displays a value (Block, Dict, Table, TableRow, or Markdown) in the terminal with navigation capabilities."
	{
		arg `value: Block, Dict, Table, TableRow, or Markdown to display interactively`
		returns `the input value or selected item from interactive display`
	}

	{
		; display { 1 2 3 }  ; interactive display, can't test in automated tests
	}

	{
``	}

	group "_.." 
	"Shorthand alias for 'display' - interactively displays a value in the terminal with navigation capabilities."
	{
		arg `value: Block, Dict, Table, or TableRow to display interactively`
		returns `the input value or selected item from interactive display`
	}

	{
		; _.. { 1 2 3 }  ; interactive display, can't test in automated tests
	}

	{
``	}

	group "display\\custom" 
	"Interactively displays a Table in the terminal with a custom rendering function for each row."
	{
		arg `value: Table to display interactively`
		arg `renderer: Function that takes a row and current position indicator`
		returns `the input value or selected item from interactive display`
	}

	{
		; display\custom my-table { |row curr| ... }  ; interactive display with custom renderer
	}

	{
``	}

	group "capture-stdout" 
	"Executes a block of code while capturing all output to stdout, returning the captured output as a string."
	{
		arg `block: Block of code to execute with captured stdout`
		returns `string containing all output captured during block execution`
	}

	{
		equal { capture-stdout { print "hello" } } "hello\n"
		equal { capture-stdout { loop 3 { prns "x" } } } "x x x "
	}

	{
``	}

}

section "Default" "" {
	group "fail" 
	"Creates an error and sets the failure flag, but continues execution (unlike ^fail)."
	{
		arg `error_info: String message, Integer code, or block for multiple parameters`
		returns `error object and sets the failure flag`
	}

	{
		equal { try { fail "error message" } |type? } 'error
		equal { try { fail "error message" } |message? } "error message"
		equal { try { fail 404 } |status? } 404
	}

	{
``	}

	group "^fail" 
	"Creates an error and immediately returns from the current function with failure state."
	{
		arg `error_info: String message, Integer code, or block for multiple parameters`
		returns `error object and sets both failure and return flags`
	}

	{
		equal { ff:: fn { } { ^fail "error message" } ff |disarm |type? } 'error
		equal { ff:: fn { } { ^fail "error message" } ff |disarm |message? } "error message"
		equal { ff:: fn { } { ^fail 404 } ff |disarm |status? } 404
		equal { ff:: fn { } { ^fail 'user-error } ff |disarm  |kind? } 'user-error
	}

	{
``	}

	group "failure" 
	"Creates an error object without setting any flags (unlike fail and ^fail)."
	{
		arg `error_info: String message, Integer code, or block for multiple parameters`
		returns `error object without setting any flags`
	}

	{
		equal { failure "error message" |type? } 'error
		equal { failure "error message" |message? } "error message"
		equal { failure 404 |status? } 404
	}

	{
``	}

	group "failure\\wrap" 
	"Creates a new error that wraps an existing error, allowing for error chaining."
	{
		arg `error_info: String message, Integer code, or block for multiple parameters`
		arg `error: Error object to wrap`
		returns `new error object that wraps the provided error`
	}

	{
		equal { failure\wrap "outer error" failure "inner error" |message? } "outer error"
		equal { failure\wrap "outer error" failure "inner error" |type? } 'error
	}

	{
``	}

	group "is-error" 
	"Returns true if the value is an error, false otherwise."
	{
		arg `value: Any value to check`
		returns `boolean true if the value is an error, false otherwise`
	}

	{
		equal { is-error failure "test" } true
		equal { is-error 123 } false
	}

	{
``	}

	group "error-kind?" 
	"Returns the kind of an error, or void if not an error."
	{
		arg `value: Any value to check`
		returns `the kind of the error as a word, or void if not an error`
	}

	{
		equal { error-kind? failure { 'syntax-error 404 "Syntax error" } } 'syntax-error
		equal { error-kind? 123 } _
	}

	{
``	}

	group "is-error-of-kind" 
	"Returns true if the value is an error of the specified kind, false otherwise."
	{
		arg `error: Error object to check`
		arg `kind: Word or tagword representing the error kind to check against`
		returns `boolean true if the error is of the specified kind, false otherwise`
	}

	{
		equal { is-error-of-kind failure { 'syntax-error 404 "Syntax error" } 'syntax-error } true
		equal { is-error-of-kind failure { 'syntax-error 404 "Syntax error" } 'runtime-error } false
	}

	{
``	}

	group "cause?" 
	"Extracts the root cause from an error chain by traversing the Parent references."
	{
		arg `error: Error object to extract the root cause from`
		returns `the root cause error from an error chain`
	}

	{
		equal { cause? failure\wrap "outer error" failure "inner error" |message? } "inner error"
		equal { cause? failure "single error" |message? } "single error"
	}

	{
``	}

	group "status?" 
	"Extracts the numeric status code from an error object."
	{
		arg `error: Error object to extract status code from`
		returns `integer status code of the error`
	}

	{
		equal { failure 404 |status? } 404
		equal { failure "message" |status? } 0
		error { "not an error" |status? }
	}

	{
``	}

	group "message?" 
	"Extracts the message string from an error object."
	{
		arg `error: Error object to extract message from`
		returns `string message of the error`
	}

	{
		equal { failure "error message" |message? } "error message"
		equal { failure 404 |message? } ""
		error { "not an error" |message? }
	}

	{
``	}

	group "details?" 
	"Extracts additional details from an error object as a dictionary."
	{
		arg `error: Error object to extract additional details from`
		returns `dictionary containing any additional values stored in the error`
	}

	{
		; equal { failure { "code" 404 "info" "Not Found" } |details? |type? } 'dict
		; equal { failure { "code" 404 "info" "Not Found" } |details? .code } 404
		error { "not an error" |details? }
	}

	{
``	}

	group "has-failed" 
	"Tests if a value is an error object, returning true for errors and false for non-errors."
	{
		arg `value: Any value to check`
		returns `boolean true if the value is an error, false otherwise`
	}

	{
		equal { has-failed failure "error" } true
		equal { has-failed "not an error" } false
		equal { has-failed 123 } false
		equal { has-failed try { fail "error" } } true
	}

	{
``	}

	group "is-failure" 
	"Checks if a value is a failure/error type. Unlike has-failed, this doesn't accept failures - the value must already be disarmed."
	{
		arg `value: Any value to check (must already be disarmed if it was a failure)`
		returns `boolean true if the value is an error type, false otherwise`
	}

	{
		equal { try { fail "error" } |disarm |is-failure } true
		equal { failure "error" |is-failure } true
		equal { 123 |is-failure } false
		equal { "hello" |is-failure } false
	}

	{
``	}

	group "is-success" 
	"Returns true for any value that is not a failure/error type. The opposite of is-failure."
	{
		arg `value: Any value to check (must already be disarmed if it was a failure)`
		returns `boolean true if the value is not an error type, false if it is an error`
	}

	{
		equal { 123 |is-success } true
		equal { "hello" |is-success } true
		equal { { 1 2 3 } |is-success } true
		equal { failure "error" |is-success } false
		equal { try { fail "error" } |disarm |is-success } false
	}

	{
``	}

	group "disarm" 
	"Clears the failure flag while preserving the error object, allowing error inspection without propagation."
	{
		arg `error: Error object to disarm`
		returns `the original error object, but clears the failure flag`
	}

	{
		equal { try { fail "error" |disarm } |type? } 'error
		equal { try { fail "error" |disarm |message? } } "error"
		equal { try { fail "error" } |has-failed } true
		equal { try { fail "error" |disarm } |has-failed } false
	}

	{
``	}

	group "check" 
	"Checks if a value is in failure state and wraps it with a new error if so, otherwise returns the original value."
	{
		arg `value: Value to check for failure state`
		arg `error_info: Error information to use if value is in failure state`
		returns `original value if not in failure state, or a new error wrapping the original error`
	}

	{
		equal { 5 |check "Value must be positive" } 5
		equal { try { fail "Original error" |check "Wrapped error" } |message? } "Wrapped error"
		equal { try { fail "Original error" |check "Wrapped error" } |details? |type? } 'dict
	}

	{
``	}

	group "^check" 
	"Like 'check' but also sets the return flag to immediately exit the current function."
	{
		arg `value: Value to check for failure state`
		arg `error_info: Error information to use if value is in failure state`
		returns `original value if not in failure state, or immediately returns from function with a new error`
	}

	{
		equal { fn { x } { x |^check "Error in function" } |apply [ 5 ] } 5
		equal { ff: fn { x } { fail "Original" |^check "Wrapped" } ff 5 |disarm |message? } "Wrapped"
	}

	{
``	}

	group "^ensure" 
	"Checks if a value is truthy and returns it if so, otherwise creates an error and immediately returns from the function."
	{
		arg `condition: Value to test for truthiness`
		arg `error_info: Error information to use if condition is not truthy`
		returns `condition value if truthy, or immediately returns from function with an error`
	}

	{
		equal { fn { x } { x > 0 |^ensure "Must be positive" } |apply [ 5 ] } true
		equal { ff:: fn { x } { x > 0 |^ensure "Must be positive" } ff -1 |disarm |message? } "Must be positive"
	}

	{
``	}

	group "ensure" 
	"Checks if a value is truthy and returns it if so, otherwise creates an error with the failure flag set."
	{
		arg `condition: Value to test for truthiness`
		arg `error_info: Error information to use if condition is not truthy`
		returns `condition value if truthy, or creates an error with failure flag set`
	}

	{
		equal { 5 > 0 |ensure "Must be positive" } true
		equal { try { -1 > 0 |ensure "Must be positive" } |message? } "Must be positive"
	}

	{
``	}

	group "requires-one-of" 
	"Validates that a value matches one of the provided options, failing with a descriptive error if not."
	{
		arg `value: Value to check against valid options`
		arg `options: Block containing valid values`
		returns `original value if it matches one of the options, or creates an error with failure flag set`
	}

	{
		equal { "a" |requires-one-of { "a" "b" "c" } } "a"
		equal { "b" |requires-one-of { "a" "b" "c" } } "b"
		equal { try { "x" |requires-one-of { "a" "b" "c" } } |message? |contains "must be one of" } 1
		equal { try { "x" |requires-one-of { "a" "b" "c" } } |message? |contains "\"x\"" } 1
		equal { try { 5 |requires-one-of { 1 2 3 } } |message? |contains "5" } 1
	}

	{
``	}

	group "^requires-one-of" 
	"Validates that a value matches one of the provided options, failing with a descriptive error if not."
	{
		arg `value: Value to check against valid options`
		arg `options: Block containing valid values`
		returns `original value if it matches one of the options, or creates an error with failure flag set`
	}

	{
		equal { "a" |requires-one-of { "a" "b" "c" } } "a"
		equal { "b" |requires-one-of { "a" "b" "c" } } "b"
		equal { try { "x" |requires-one-of { "a" "b" "c" } } |message? |contains "must be one of" } 1
		equal { try { "x" |requires-one-of { "a" "b" "c" } } |message? |contains "\"x\"" } 1
		equal { try { 5 |requires-one-of { 1 2 3 } } |message? |contains "5" } 1
	}

	{
``	}

	group "fix" 
	"Handles errors by executing a block if the value is in failure state, clearing the failure flag."
	{
		arg `value: Value to check for failure state`
		arg `handler: Block to execute if value is in failure state`
		returns `original value if not in failure state, or result of executing the handler block`
	}

	{
		equal { 5 |fix { + 10 } } 5
		equal { try { fail "error" |fix { "fixed" } } } "fixed"
		equal { try { fail "error" |fix { fail "new error" } } |message? } "new error"
	}

	{
``	}

	group "^fix" 
	"Like 'fix' but also sets the return flag to immediately exit the current function with the handler result."
	{
		arg `value: Value to check for failure state`
		arg `handler: Block to execute if value is in failure state`
		returns `original value if not in failure state, or immediately returns from function with handler result`
	}

	{
		equal { fn { x } { x |^fix { "fixed" } } |apply [ 5 ] } 5
		equal { ff:: fn { x } { fail "error" |^fix { "fixed" } } ff 5 } "fixed"
	}

	{
``	}

	group "fix\\either" 
	"Executes one of two blocks depending on whether the value is in failure state."
	{
		arg `value: Value to check for failure state`
		arg `error_handler: Block to execute if value is in failure state`
		arg `success_handler: Block to execute if value is not in failure state`
		returns `result of executing the appropriate handler block`
	}

	{
		equal { fix\either failure "error" { "fixed" } { "not fixed" } } "fixed"
		equal { fix\either 5 { "fixed" } { "not fixed" } } "not fixed"
	}

	{
``	}

	group "fix\\else" 
	"Executes a block if the value is not in failure state, otherwise returns the original value."
	{
		arg `value: Value to check for failure state`
		arg `success_handler: Block to execute if value is not in failure state`
		returns `result of executing the success handler if value is not in failure state, or the original value`
	}

	{
		equal { 5 |fix\else { "not fixed" } } "not fixed"
		equal { try { fail "error" |fix\else { "not fixed" } } |message? } "error"
	}

	{
``	}

	group "fix\\continue" 
	"Executes one of two blocks depending on whether the value is in failure state, like an error-handling if/else."
	{
		arg `value: Value to check for failure state`
		arg `error_handler: Block to execute if value is in failure state`
		arg `success_handler: Block to execute if value is not in failure state`
		returns `result of executing the appropriate handler block`
	}

	{
		equal { 5 |fix\continue { "error handler" } { "success handler" } } "success handler"
		equal { try { fail "error" |fix\continue { "error handler" } { "success handler" } } } "error handler"
	}

	{
``	}

	group "continue" 
	"Executes a block only if the value is not in failure state, opposite of 'fix'."
	{
		arg `value: Value to check for failure state`
		arg `block: Block to execute if value is not in failure state`
		returns `result of executing the block if value is not in failure state, or the original value`
	}

	{
		equal { 5 |continue { + 10 } } 15
		equal { try { fail "error" |continue { + 10 } } } failure "error"
	}

	{
``	}

	group "^fix\\match" 
	"Error handling switch that matches error codes with handler blocks and sets the return flag."
	{
		arg `error: Error object to match against`
		arg `cases: Block containing error codes and corresponding handler blocks`
		returns `result of executing the matching handler block, or the original error if no match`
	}

	{
		equal { ^fix\match failure 404 { 404 { "Not Found" } 500 { "Server Error" } } } "Not Found"
		equal { ^fix\match failure 500 { 404 { "Not Found" } 500 { "Server Error" } } } "Server Error"
		equal { ^fix\match failure 403 { 404 { "Not Found" } 500 { "Server Error" } _ { "Unknown Error" } } } "Unknown Error"
	}

	{
``	}

	group "try" 
	"Takes a block of code and does (runs) it."
	{
	}

	{
		equal  { try { 123 + 123 } } 246
		equal  { try { 123 + "asd" } |type? } 'error
		equal  { try { 123 + } |type? } 'error
	}

	{
``	}

	group "try-all" 
	"Executes a block and returns a result tuple [success, result], where success is true if no error occurred."
	{
		arg `block: Block of code to execute`
		returns `a block containing [success, result], where success is true if no error occurred`
	}

	{
		equal { try-all { 1 + 2 } } [ true 3 ]
		equal { try-all { fail "custom error" } |first } false
	}

	{
``	}

	group "try\\in" 
	"Takes a Context and a Block. It Does a block inside a given Context."
	{
	}

	{
		equal  { c: context { x: 100 } try\in c { x * 9.99 } } 999.0
		equal  { c: context { x: 100 } try\in c { inc! 'x } } 101
		equal  { c: context { x: 100 } try\in c { x:: 200 , x } } 200
		equal  { c: context { x: 100 } try\in c { x:: 200 } c/x } 200
		equal  { c: context { x: 100 } try\in c { inc! 'y } |type? } 'error
	}

	{
``	}

	group "finally" 
	"Executes a block and ensures another block is executed afterward, regardless of errors."
	{
		arg `main-block: Block of code to execute`
		arg `finally-block: Block to execute afterward, regardless of errors`
		returns `result of the main block, preserving any failure state`
	}

	{
		equal { finally { 1 + 2 } { print "cleanup" } } 3
		equal { try { finally { fail "error" } { print "cleanup" } } |message? } "error"
	}

	{
``	}

	group "retry" 
	"Executes a block and retries it up to N times if it results in a failure."
	{
		arg `retries: Integer number of retries to attempt`
		arg `block: Block of code to execute and potentially retry`
		returns `result of the block if successful, or the last failure if all retries fail`
	}

	{
		; equal { retry 3 { fail 101 } |disarm |type? } 'error
		; equal { retry 3 { fail 101 } |disarm |status? } 101
		equal { retry 3 { 10 + 1 } } 11
	}

	{
``	}

	group "persist" 
	"Executes a block repeatedly until it succeeds (no failure), then returns the successful result. Gives up after 1000 attempts."
	{
		arg `block: Block of code to execute repeatedly until it succeeds`
		returns `result of the block when it finally succeeds (no failure), or error if 1000 attempts exceeded`
	}

	{
		equal { persist { 10 + 1 } } 11
		equal { counter:: 0 persist { counter:: counter + 1 , if counter > 3 { counter } { fail "not ready" } } } 4
		error { persist { fail "always fails" } }
	}

	{
``	}

	group "timeout" 
	"Executes a block of code with a timeout, failing if execution exceeds the specified duration in milliseconds."
	{
		arg `ms: Integer timeout duration in milliseconds`
		arg `block: Block of code to execute with a timeout`
		returns `result of the block if it completes within the timeout, or a timeout error`
	}

	{
		equal { timeout 5000 { "ok" } } "ok"
		equal { try { timeout 100 { sleep 1000 , "ok" } } |message? |contains "timeout" } 1
	}

	{
``	}

}

