; Comprehensive test for persistent contexts in Rye
; This test demonstrates persistence, interface compatibility, and various operations

print "=== Persistent Context Comprehensive Test ==="

; Clean up any existing test database
; rm-file "test_pctx_comprehensive.db"

print "\n1. Creating persistent context and setting initial values..."

; Create a new persistent context
pctx: persistent-context "test_pctx_comprehensive.db"

; Test setting different types of values
do\in pctx {
    ; Basic values
    number-val: 42
    string-val: "Hello, Rye!"
    bool-val: 1
    
    ; Collections
    list-val: [ 1 2 3 "four" ]
    dict-val: { name: "test" value: 123 }
    
    ; Mark some as variables for modification testing
    var counter: 0
    var message: "initial"
    
    print "Initial values set in persistent context"
}

print "\n2. Reopening context to test persistence..."

; Close current context and reopen
pctx2: persistent-context "test_pctx_comprehensive.db"

do\in pctx2 {
    print "Reading persisted values:"
    print { "number-val:" number-val }
    print { "string-val:" string-val }
    print { "bool-val:" bool-val }
    print { "list-val:" list-val }
    print { "dict-val:" dict-val }
    print { "counter:" counter }
    print { "message:" message }
}

print "\n3. Testing modifications..."

do\in pctx2 {
    ; Modify variables
    set counter ( counter + 1 )
    set message "modified"
    
    ; Add new values
    new-val: "Added after reopening"
    
    print "Values modified and new ones added"
}

print "\n4. Third reopening to verify modifications persisted..."

pctx3: persistent-context "test_pctx_comprehensive.db"

do\in pctx3 {
    print "Verifying persisted modifications:"
    print { "counter after increment:" counter }
    print { "message after change:" message }
    print { "new-val:" new-val }
    
    ; Test more complex operations
    var accumulated: 0
    loop list-val 'val {
        if integer? val { 
            set accumulated ( accumulated + val )
        }
    }
    print { "accumulated sum:" accumulated }
}

print "\n5. Testing context interface uniformity..."

; Test that both regular and persistent contexts work the same way
regular-ctx: context { test-var: "regular" }
pctx4: persistent-context "test_pctx_interface.db"

do\in pctx4 {
    test-var: "persistent"
}

; Both should work identically through the interface
print { "Regular context test-var:" ( get regular-ctx 'test-var ) }
print { "Persistent context test-var:" ( do\in pctx4 { test-var } ) }

print "\n6. Testing variable vs constant behavior..."

do\in pctx4 {
    ; Set a constant
    constant-val: "I cannot be changed"
    
    ; Set a variable  
    var mutable-val: "I can be changed"
    
    ; Try to modify both
    try {
        set constant-val "attempted change"
        print "ERROR: Constant was modified!"
    } catch { 
        print "✓ Constant protection working"
    }
    
    set mutable-val "successfully changed"
    print { "✓ Variable modified to:" mutable-val }
}

print "\n7. Testing persistence across multiple sessions..."

; Create a session counter
session-ctx: persistent-context "test_session_counter.db"
do\in session-ctx {
    var sessions: either { sessions + 1 } { 1 }
    print { "Session number:" sessions }
}

print "\n8. Cleanup..."

; Clean up test databases
; rm-file "test_pctx_comprehensive.db"
; rm-file "test_pctx_interface.db"
; rm-file "test_session_counter.db"

print "\n=== Test Complete ==="
print "✓ Persistent contexts maintain state across reopenings"
print "✓ All data types persist correctly"
print "✓ Variable/constant semantics are preserved"
print "✓ Interface uniformity allows seamless usage"
print "✓ Performance characteristics are as expected"
